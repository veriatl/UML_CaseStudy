helper context UML!AcceptCallAction def: result_pins(): Boolean = 
  UML!AcceptCallAction.allInstances()->forAll(aca |
    let parameter : OrderedSet(UML!Parameter) = 
      aca.trigger->collect(t| 
        t.event)->asSequence()->first().oclAsType(UML!CallEvent).operation.inputParameters() in 
        aca.result->size() = parameter->size() and Sequence{}->forAll(i| 
          parameter->at(i).type.conformsTo(aca.result->at(i).type) and parameter->at(i).isOrdered = aca.result->at(i).isOrdered and parameter->at(i).compatibleWith(aca.result->at(i)))
); 

helper context UML!AcceptCallAction def: trigger_call_event(): Boolean = 
  UML!AcceptCallAction.allInstances()->forAll(aca |
    aca.trigger->size() = 1 and aca.trigger->asSequence()->first().event.oclIsKindOf(UML!CallEvent)
); 

helper context UML!AcceptCallAction def: unmarshall(): Boolean = 
  UML!AcceptCallAction.allInstances()->forAll(aca |
    aca.isUnmarshall = true
); 

helper context UML!AcceptEventAction def: one_output_pin(): Boolean = 
  UML!AcceptEventAction.allInstances()->forAll(aea |
    not(aea.isUnmarshall) and aea.trigger->exists(t| 
      t.event.oclIsKindOf(UML!SignalEvent) or t.event.oclIsKindOf(UML!TimeEvent)) implies aea.output->size() = 1 and aea.output->first()->is(1,1.toUnlimitedNatural())
); 

helper context UML!AcceptEventAction def: no_input_pins(): Boolean = 
  UML!AcceptEventAction.allInstances()->forAll(aea |
    aea.input->size() = 0
); 

helper context UML!AcceptEventAction def: no_output_pins(): Boolean = 
  UML!AcceptEventAction.allInstances()->forAll(aea |
    aea.oclIsTypeOf(UML!AcceptEventAction) and aea.trigger->forAll(t| 
      t.event.oclIsKindOf(UML!ChangeEvent) or t.event.oclIsKindOf(UML!CallEvent)) implies aea.output->size() = 0
); 

helper context UML!AcceptEventAction def: unmarshall_signal_events(): Boolean = 
  UML!AcceptEventAction.allInstances()->forAll(aea |
    aea.isUnmarshall and aea.oclIsTypeOf(UML!AcceptEventAction) implies aea.trigger->size() = 1 and aea.trigger->asSequence()->first().event.oclIsKindOf(UML!SignalEvent) and let attribute : OrderedSet(UML!Property) = 
      aea.trigger->asSequence()->first().event.oclAsType(UML!SignalEvent).signal.allAttributes() in 
        attribute->size() > 0 and aea.result->size() = attribute->size() and Sequence{}->forAll(i| 
          aea.result->at(i).type = attribute->at(i).type and aea.result->at(i).isOrdered = attribute->at(i).isOrdered and aea.result->at(i).includesMultiplicity(attribute->at(i)))
); 

helper context UML!AcceptEventAction def: conforming_type(): Boolean = 
  UML!AcceptEventAction.allInstances()->forAll(aea |
    not(aea.isUnmarshall) implies aea.result->isEmpty() or let type : UML!Type = 
      aea.result->first().type in 
        type = OclUndefined or aea.trigger->forAll(t| 
          t.event.oclIsKindOf(UML!SignalEvent)) and aea.trigger->collect(t| 
          t.event)->collect(e| 
          e.oclAsType(UML!SignalEvent))->collect(se| 
          se.signal)->forAll(s| 
          s.conformsTo(type))
); 

helper context UML!ActionExecutionSpecification def: action_referenced(): Boolean = 
  UML!ActionExecutionSpecification.allInstances()->forAll(aes |
    aes.enclosingInteraction->oclAsSet()->notEmpty() or aes.enclosingOperand.operand->oclAsSet()->notEmpty() and let parentInteraction : Set(UML!Interaction) = 
      aes.enclosingInteraction.oclAsType(UML!Interaction)->oclAsSet()->asSet().() in 
        parentInteraction->size() = 1 and aes.action.action->oclAsSet()->asSet() = parentInteraction
); 

helper context UML!ActionInputPin def: input_pin(): Boolean = 
  UML!ActionInputPin.allInstances()->forAll(aip |
    aip.fromAction.input->forAll(ip| 
      ip.oclIsKindOf(UML!ActionInputPin))
); 

helper context UML!ActionInputPin def: one_output_pin(): Boolean = 
  UML!ActionInputPin.allInstances()->forAll(aip |
    aip.fromAction.output->size() = 1
); 

helper context UML!ActionInputPin def: no_control_or_object_flow(): Boolean = 
  UML!ActionInputPin.allInstances()->forAll(aip |
    aip.fromAction.incoming.()->isEmpty() and aip.fromAction.input->collect(ip| 
      ip.incoming)->isEmpty() and aip.fromAction.output->collect(op| 
      op.outgoing)->isEmpty()
); 

helper context UML!Activity def: maximum_one_parameter_node(): Boolean = 
  UML!Activity.allInstances()->forAll(a |
    a.ownedParameter->forAll(p| 
      p.direction <> ParameterDirectionKind.inout implies a.node->select(an| 
        an.oclIsKindOf(UML!ActivityParameterNode) and an.oclAsType(UML!ActivityParameterNode).parameter = p)->size() = 1)
); 

helper context UML!Activity def: maximum_two_parameter_nodes(): Boolean = 
  UML!Activity.allInstances()->forAll(a |
    a.ownedParameter->forAll(p| 
      p.direction = ParameterDirectionKind.inout implies let associatedNodes : Set(UML!ActivityNode) = 
        a.node->select(an| 
          an.oclIsKindOf(UML!ActivityParameterNode) and an.oclAsType(UML!ActivityParameterNode).parameter = p) in 
          associatedNodes->size() = 2 and associatedNodes->select(an| 
            an.incoming->notEmpty())->size() <= 1 and associatedNodes->select(an| 
            an.outgoing->notEmpty())->size() <= 1)
); 

helper context UML!ActivityEdge def: source_and_target(): Boolean = 
  UML!ActivityEdge.allInstances()->forAll(ae |
    ae.activity <> OclUndefined implies ae.source.containingActivity() = ae.activity and ae.target.containingActivity() = ae.activity
); 

helper context UML!ActivityGroup def: nodes_and_edges(): Boolean = 
  UML!ActivityGroup.allInstances()->forAll(ag |
    ag.containedNode->forAll(an| 
      an.activity = ag.containingActivity()) and ag.containedEdge->forAll(ae| 
      ae.activity = ag.containingActivity())
); 

helper context UML!ActivityGroup def: not_contained(): Boolean = 
  UML!ActivityGroup.allInstances()->forAll(ag |
    ag.subgroup->closure(ag| 
      ag.subgroup)->collect(ag| 
      ag.containedNode)->excludesAll(ag.containedNode) and ag.superGroup->oclAsSet()->closure(ag| 
      ag.superGroup)->collect(ag| 
      ag.containedNode)->excludesAll(ag.containedNode) and ag.subgroup->closure(ag| 
      ag.subgroup)->collect(ag| 
      ag.containedEdge)->excludesAll(ag.containedEdge) and ag.superGroup->oclAsSet()->closure(ag| 
      ag.superGroup)->collect(ag| 
      ag.containedEdge)->excludesAll(ag.containedEdge)
); 

helper context UML!ActivityParameterNode def: no_outgoing_edges(): Boolean = 
  UML!ActivityParameterNode.allInstances()->forAll(apn |
    apn.incoming->notEmpty() and apn.outgoing->isEmpty() implies apn.parameter.direction = ParameterDirectionKind.out or apn.parameter.direction = ParameterDirectionKind.inout or apn.parameter.direction = ParameterDirectionKind.return
); 

helper context UML!ActivityParameterNode def: has_parameters(): Boolean = 
  UML!ActivityParameterNode.allInstances()->forAll(apn |
    apn.activity.ownedParameter->includes(apn.parameter)
); 

helper context UML!ActivityParameterNode def: same_type(): Boolean = 
  UML!ActivityParameterNode.allInstances()->forAll(apn |
    apn.type = apn.parameter.type
); 

helper context UML!ActivityParameterNode def: no_incoming_edges(): Boolean = 
  UML!ActivityParameterNode.allInstances()->forAll(apn |
    apn.outgoing->notEmpty() and apn.incoming->isEmpty() implies apn.parameter.direction = ParameterDirectionKind.in or apn.parameter.direction = ParameterDirectionKind.inout
); 

helper context UML!ActivityParameterNode def: no_edges(): Boolean = 
  UML!ActivityParameterNode.allInstances()->forAll(apn |
    apn.incoming->isEmpty() or apn.outgoing->isEmpty()
); 

helper context UML!ActivityPartition def: represents_classifier(): Boolean = 
  UML!ActivityPartition.allInstances()->forAll(ap |
    not(ap.isExternal) and ap.represents.oclIsKindOf(UML!Classifier) and ap.superPartition->oclAsSet()->notEmpty() implies let representedClassifier : UML!Classifier = 
      ap.represents.oclAsType(UML!Classifier) in 
        ap.superPartition.represents.oclIsKindOf(UML!Classifier) and let representedSuperClassifier : UML!Classifier = 
          ap.superPartition.represents.oclAsType(UML!Classifier) in 
            representedSuperClassifier.oclIsKindOf(UML!BehavioredClassifier) and representedClassifier.oclIsKindOf(UML!Behavior) and representedSuperClassifier.oclAsType(UML!BehavioredClassifier).ownedBehavior->includes(representedClassifier.oclAsType(UML!Behavior)) or representedSuperClassifier.oclIsKindOf(UML!Class) and representedSuperClassifier.oclAsType(UML!Class).nestedClassifier->includes(representedClassifier) or UML!Association->allInstances()->exists(a| 
              a.memberEnd->exists(end1| 
                end1.isComposite and end1.type = representedClassifier and a.memberEnd->exists(end2| 
                  end1 <> end2 and end2.type = representedSuperClassifier)))
); 

helper context UML!ActivityPartition def: represents_property_and_is_contained(): Boolean = 
  UML!ActivityPartition.allInstances()->forAll(ap |
    ap.represents.oclIsKindOf(UML!Property) and ap.superPartition->oclAsSet()->notEmpty() implies ap.superPartition.represents.oclIsKindOf(UML!Classifier) and ap.represents.owner = ap.superPartition.represents or ap.superPartition.represents.oclIsKindOf(UML!Property) and ap.represents.owner = ap.superPartition.represents.oclAsType(UML!Property).type
); 

helper context UML!ActivityPartition def: represents_property(): Boolean = 
  UML!ActivityPartition.allInstances()->forAll(ap |
    ap.represents.oclIsKindOf(UML!Property) and ap.superPartition->oclAsSet()->notEmpty() and ap.superPartition.represents.oclIsKindOf(UML!Classifier) implies let representedClassifier : UML!Classifier = 
      ap.superPartition.represents.oclAsType(UML!Classifier) in 
        ap.superPartition.subpartition->reject(ap| 
          ap.isExternal)->forAll(p| 
          p.represents.oclIsKindOf(UML!Property) and p.owner = representedClassifier)
); 

helper context UML!ActivityPartition def: dimension_not_contained(): Boolean = 
  UML!ActivityPartition.allInstances()->forAll(ap |
    ap.isDimension implies ap.superPartition->oclAsSet()->isEmpty()
); 

helper context UML!Actor def: associations(): Boolean = 
  UML!Actor.allInstances()->forAll(a |
    UML!Association->allInstances()->forAll(a| 
      a.memberEnd->collect(p| 
        p.type)->includes(a) implies a.memberEnd->size() = 2 and let actorEnd : UML!Property = 
        a.memberEnd->any(p| 
          p.type = a) in 
          actorEnd.opposite.class.oclIsKindOf(UML!UseCase) or actorEnd.opposite.class.oclIsKindOf(UML!Class) and not(actorEnd.opposite.class.oclIsKindOf(UML!Behavior)))
); 

helper context UML!Actor def: must_have_name(): Boolean = 
  UML!Actor.allInstances()->forAll(a |
    a.name->oclAsSet()->notEmpty()
); 

helper context UML!AddStructuralFeatureValueAction def: required_value(): Boolean = 
  UML!AddStructuralFeatureValueAction.allInstances()->forAll(asfva |
    asfva.value <> OclUndefined
); 

helper context UML!AddStructuralFeatureValueAction def: insertAt_pin(): Boolean = 
  UML!AddStructuralFeatureValueAction.allInstances()->forAll(asfva |
    if (not(asfva.structuralFeature.isOrdered)) then 
      asfva.insertAt = OclUndefined
    else 
      not(asfva.isReplaceAll) implies asfva.insertAt <> OclUndefined and asfva.insertAt->oclAsSet()->forAll(ip| 
        ip.type = UnlimitedNatural and ip->is(1,1.oclAsType(UnlimitedNatural)))
    endif
); 

helper context UML!AddVariableValueAction def: required_value(): Boolean = 
  UML!AddVariableValueAction.allInstances()->forAll(avva |
    avva.value <> OclUndefined
); 

helper context UML!AddVariableValueAction def: insertAt_pin(): Boolean = 
  UML!AddVariableValueAction.allInstances()->forAll(avva |
    if (not(avva.variable.isOrdered)) then 
      avva.insertAt = OclUndefined
    else 
      not(avva.isReplaceAll) implies avva.insertAt <> OclUndefined and avva.insertAt->oclAsSet()->forAll(ip| 
        ip.type = UnlimitedNatural and ip->is(1,1.oclAsType(UnlimitedNatural)))
    endif
); 

helper context UML!Association def: specialized_end_number(): Boolean = 
  UML!Association.allInstances()->forAll(a |
    a.parents()->select(c| 
      c.oclIsKindOf(UML!Association))->collect(c| 
      c.oclAsType(UML!Association))->forAll(p| 
      p.memberEnd->size() = a.memberEnd->size())
); 

helper context UML!Association def: specialized_end_types(): Boolean = 
  UML!Association.allInstances()->forAll(a |
    Sequence{}->forAll(i| 
      a.general->select(c| 
        c.oclIsKindOf(UML!Association))->collect(c| 
        c.oclAsType(UML!Association))->forAll(ga| 
        a.memberEnd->at(i).type.conformsTo(ga.memberEnd->at(i).type)))
); 

helper context UML!Association def: binary_associations(): Boolean = 
  UML!Association.allInstances()->forAll(a |
    a.memberEnd->exists(p| 
      p.aggregation <> AggregationKind.none) implies a.memberEnd->size() = 2 and a.memberEnd->exists(p| 
      p.aggregation = AggregationKind.none)
); 

helper context UML!Association def: association_ends(): Boolean = 
  UML!Association.allInstances()->forAll(a |
    a.memberEnd->size() > 2 implies a.ownedEnd->includesAll(a.memberEnd)
); 

helper context UML!Association def: ends_must_be_typed(): Boolean = 
  UML!Association.allInstances()->forAll(a |
    a.memberEnd->forAll(p| 
      p.type->oclAsSet()->notEmpty())
); 

helper context UML!AssociationClass def: cannot_be_defined(): Boolean = 
  UML!AssociationClass.allInstances()->forAll(ac |
    ac.endType()->excludes(ac) and ac.endType()->collect(et| 
      et.oclAsType(UML!Classifier).allParents())->flatten()->excludes(ac)
); 

helper context UML!AssociationClass def: disjoint_attributes_ends(): Boolean = 
  UML!AssociationClass.allInstances()->forAll(ac |
    ac.ownedAttribute->intersection(ac.ownedEnd)->isEmpty()
); 

helper context UML!Behavior def: most_one_behavior(): Boolean = 
  UML!Behavior.allInstances()->forAll(b |
    b.specification <> OclUndefined implies b.context.ownedBehavior->select(b| 
      b.specification = b.specification)->size() = 1
); 

helper context UML!Behavior def: parameters_match(): Boolean = 
  UML!Behavior.allInstances()->forAll(b |
    b.specification <> OclUndefined implies b.ownedParameter->size() = b.specification.ownedParameter->size()
); 

helper context UML!Behavior def: feature_of_context_classifier(): Boolean = 
  UML!Behavior.allInstances()->forAll(b |
    b.context.feature->includes(b.specification)
); 

helper context UML!BehavioralFeature def: abstract_no_method(): Boolean = 
  UML!BehavioralFeature.allInstances()->forAll(bf |
    bf.isAbstract implies bf.method->isEmpty()
); 

helper context UML!BehavioredClassifier def: class_behavior(): Boolean = 
  UML!BehavioredClassifier.allInstances()->forAll(bc |
    bc.classifierBehavior->oclAsSet()->notEmpty() implies bc.classifierBehavior.specification->oclAsSet()->isEmpty()
); 

helper context UML!BroadcastSignalAction def: number_of_arguments(): Boolean = 
  UML!BroadcastSignalAction.allInstances()->forAll(bsa |
    bsa.argument->size() = bsa.signal.allAttributes()->size()
); 

helper context UML!BroadcastSignalAction def: type_ordering_multiplicity(): Boolean = 
  UML!BroadcastSignalAction.allInstances()->forAll(bsa |
    let attribute : OrderedSet(UML!Property) = 
      bsa.signal.allAttributes() in 
        Sequence{}->forAll(i| 
          bsa.argument->at(i).type.conformsTo(attribute->at(i).type) and bsa.argument->at(i).isOrdered = attribute->at(i).isOrdered and bsa.argument->at(i).compatibleWith(attribute->at(i)))
); 

helper context UML!BroadcastSignalAction def: no_onport(): Boolean = 
  UML!BroadcastSignalAction.allInstances()->forAll(bsa |
    bsa.onPort = OclUndefined
); 

helper context UML!CallAction def: argument_pins(): Boolean = 
  UML!CallAction.allInstances()->forAll(ca |
    let parameter : OrderedSet(UML!Parameter) = 
      ca.inputParameters() in 
        ca.argument->size() = parameter->size() and Sequence{}->forAll(i| 
          ca.argument->at(i).type.conformsTo(parameter->at(i).type) and ca.argument->at(i).isOrdered = parameter->at(i).isOrdered and ca.argument->at(i).compatibleWith(parameter->at(i)))
); 

helper context UML!CallAction def: result_pins(): Boolean = 
  UML!CallAction.allInstances()->forAll(ca |
    let parameter : OrderedSet(UML!Parameter) = 
      ca.outputParameters() in 
        ca.result->size() = parameter->size() and Sequence{}->forAll(i| 
          parameter->at(i).type.conformsTo(ca.result->at(i).type) and parameter->at(i).isOrdered = ca.result->at(i).isOrdered and parameter->at(i).compatibleWith(ca.result->at(i)))
); 

helper context UML!CallAction def: synchronous_call(): Boolean = 
  UML!CallAction.allInstances()->forAll(ca |
    ca.result->notEmpty() implies ca.isSynchronous
); 

helper context UML!CallBehaviorAction def: no_onport(): Boolean = 
  UML!CallBehaviorAction.allInstances()->forAll(cba |
    cba.onPort = OclUndefined
); 

helper context UML!CallOperationAction def: type_target_pin(): Boolean = 
  UML!CallOperationAction.allInstances()->forAll(coa |
    if (coa.onPort = OclUndefined) then 
      coa.target.type.oclAsType(UML!Classifier).allFeatures()->includes(coa.operation)
    else 
      coa.target.type.oclAsType(UML!Classifier).allFeatures()->includes(coa.onPort) and coa.onPort.provided.()->collect(i| 
        i.allFeatures())->includes(coa.operation)
    endif
); 

helper context UML!Class def: passive_class(): Boolean = 
  UML!Class.allInstances()->forAll(c |
    not(c.isActive) implies c.ownedReception->isEmpty() and c.classifierBehavior = OclUndefined
); 

helper context UML!Classifier def: specialize_type(): Boolean = 
  UML!Classifier.allInstances()->forAll(c |
    c.parents()->forAll(c| 
      c.maySpecializeType(c))
); 

helper context UML!Classifier def: maps_to_generalization_set(): Boolean = 
  UML!Classifier.allInstances()->forAll(c |
    c.powertypeExtent->forAll(gs| 
      gs.generalization->forAll(gen| 
        not(gen.general = c) and not(gen.general.allParents()->includes(c)) and not(gen.specific = c) and not(c.allParents()->includes(gen.specific))))
); 

helper context UML!Classifier def: non_final_parents(): Boolean = 
  UML!Classifier.allInstances()->forAll(c |
    c.parents()->forAll(c| 
      not(c.isFinalSpecialization))
); 

helper context UML!Classifier def: no_cycles_in_generalization(): Boolean = 
  UML!Classifier.allInstances()->forAll(c |
    not(c.allParents()->includes(c))
); 

helper context UML!ClassifierTemplateParameter def: has_constraining_classifier(): Boolean = 
  UML!ClassifierTemplateParameter.allInstances()->forAll(ctp |
    ctp.allowSubstitutable implies ctp.constrainingClassifier->notEmpty()
); 

helper context UML!ClassifierTemplateParameter def: parametered_element_no_features(): Boolean = 
  UML!ClassifierTemplateParameter.allInstances()->forAll(ctp |
    ctp.parameteredElement.feature->isEmpty() and ctp.constrainingClassifier->isEmpty() implies ctp.parameteredElement.allParents()->isEmpty()
); 

helper context UML!ClassifierTemplateParameter def: matching_abstract(): Boolean = 
  UML!ClassifierTemplateParameter.allInstances()->forAll(ctp |
    not(ctp.parameteredElement.isAbstract) implies ctp.formal->collect(tps| 
      tps.actual)->forAll(a| 
      not(a.oclAsType(UML!Classifier).isAbstract))
); 

helper context UML!ClassifierTemplateParameter def: actual_is_classifier(): Boolean = 
  UML!ClassifierTemplateParameter.allInstances()->forAll(ctp |
    ctp.formal->collect(tps| 
      tps.actual)->forAll(a| 
      a.oclIsKindOf(UML!Classifier))
); 

helper context UML!ClassifierTemplateParameter def: constraining_classifiers_constrain_args(): Boolean = 
  UML!ClassifierTemplateParameter.allInstances()->forAll(ctp |
    ctp.formal->collect(tps| 
      tps.actual)->forAll(a| 
      let arg : UML!Classifier = 
        a.oclAsType(UML!Classifier) in 
          ctp.constrainingClassifier->forAll(cc| 
            arg = cc or arg.conformsTo(cc) or ctp.allowSubstitutable and arg.isSubstitutableFor(cc)))
); 

helper context UML!ClassifierTemplateParameter def: constraining_classifiers_constrain_parametered_element(): Boolean = 
  UML!ClassifierTemplateParameter.allInstances()->forAll(ctp |
    ctp.constrainingClassifier->forAll(cc| 
      ctp.parameteredElement = cc or ctp.parameteredElement.conformsTo(cc) or ctp.allowSubstitutable and ctp.parameteredElement.isSubstitutableFor(cc))
); 

helper context UML!Clause def: body_output_pins(): Boolean = 
  UML!Clause.allInstances()->forAll(c |
    c.body->collect(en| 
      en.oclAsType(UML!Action))->collect(a| 
      a.allActions())->collect(a| 
      a.output)->includesAll(c.bodyOutput)
); 

helper context UML!Clause def: decider_output(): Boolean = 
  UML!Clause.allInstances()->forAll(c |
    c.test->collect(en| 
      en.oclAsType(UML!Action))->collect(a| 
      a.allActions())->collect(a| 
      a.output)->includes(c.decider) and c.decider.type = Boolean and c.decider->is(1,1.toUnlimitedNatural())
); 

helper context UML!Clause def: test_and_body(): Boolean = 
  UML!Clause.allInstances()->forAll(c |
    c.test->intersection(c.body)->isEmpty()
); 

helper context UML!ClearAssociationAction def: multiplicity(): Boolean = 
  UML!ClearAssociationAction.allInstances()->forAll(caa |
    caa.object->is(1,1.toUnlimitedNatural())
); 

helper context UML!ClearAssociationAction def: same_type(): Boolean = 
  UML!ClearAssociationAction.allInstances()->forAll(caa |
    caa.association.memberEnd->exists(p| 
      caa.object.type.conformsTo(p.type))
); 

helper context UML!ClearStructuralFeatureAction def: type_of_result(): Boolean = 
  UML!ClearStructuralFeatureAction.allInstances()->forAll(csfa |
    csfa.result <> OclUndefined implies csfa.result.type = csfa.object.type
); 

helper context UML!ClearStructuralFeatureAction def: multiplicity_of_result(): Boolean = 
  UML!ClearStructuralFeatureAction.allInstances()->forAll(csfa |
    csfa.result <> OclUndefined implies csfa.result->is(1,1.toUnlimitedNatural())
); 

helper context UML!CollaborationUse def: client_elements(): Boolean = 
  UML!CollaborationUse.allInstances()->forAll(cu |
    cu.roleBinding->collect(d| 
      d.client)->forAll(ne1,ne2| 
      ne1.oclIsKindOf(UML!ConnectableElement) and ne2.oclIsKindOf(UML!ConnectableElement) and let ce1 : UML!ConnectableElement = 
        ne1.oclAsType(UML!ConnectableElement) in 
          let ce2 : UML!ConnectableElement = 
            ne2.oclAsType(UML!ConnectableElement) in 
              ce1.role = ce2.role) and cu.roleBinding->collect(d| 
      d.supplier)->forAll(ne1,ne2| 
      ne1.oclIsKindOf(UML!ConnectableElement) and ne2.oclIsKindOf(UML!ConnectableElement) and let ce1 : UML!ConnectableElement = 
        ne1.oclAsType(UML!ConnectableElement) in 
          let ce2 : UML!ConnectableElement = 
            ne2.oclAsType(UML!ConnectableElement) in 
              ce1.collaborationRole = ce2.collaborationRole)
); 

helper context UML!CollaborationUse def: every_role(): Boolean = 
  UML!CollaborationUse.allInstances()->forAll(cu |
    cu.type.collaborationRole->forAll(role| 
      cu.roleBinding->exists(rb| 
        rb.supplier->includes(role)))
); 

helper context UML!CollaborationUse def: connectors(): Boolean = 
  UML!CollaborationUse.allInstances()->forAll(cu |
    cu.type.ownedConnector->forAll(connector| 
      let rolesConnectedInCollab : Set(UML!ConnectableElement) = 
        connector.end->collect(ce| 
          ce.role)->asSet() in 
          let relevantBindings : Set(UML!Dependency) = 
            cu.roleBinding->select(rb| 
              rb.supplier->intersection(rolesConnectedInCollab)->notEmpty()) in 
              let boundRoles : Set(UML!ConnectableElement) = 
                relevantBindings->collect(d| 
                  d.client->collect(ne| 
                    ne.oclAsType(UML!ConnectableElement)))->asSet() in 
                  let contextClassifier : UML!StructuredClassifier = 
                    boundRoles->any(ce| 
                      true).role->any(sc| 
                      true) in 
                      contextClassifier.ownedConnector->exists(correspondingConnector| 
                        correspondingConnector.end->collect(ce| 
                          ce.role)->forAll(role| 
                          boundRoles->includes(role)) and connector.type->oclAsSet()->notEmpty() and correspondingConnector.type->oclAsSet()->notEmpty() implies connector.type->oclAsSet()->forAll(a| 
                          a.conformsTo(correspondingConnector.type))))
); 

helper context UML!CombinedFragment def: break(): Boolean = 
  UML!CombinedFragment.allInstances()->forAll(cf |
    cf.interactionOperator = InteractionOperatorKind.break implies cf.enclosingInteraction.oclAsType(UML!InteractionFragment)->oclAsSet()->asSet().()->collect(if| 
      if.covered)->asSet() = cf.covered->asSet()
); 

helper context UML!CombinedFragment def: consider_and_ignore(): Boolean = 
  UML!CombinedFragment.allInstances()->forAll(cf |
    cf.interactionOperator = InteractionOperatorKind.consider or cf.interactionOperator = InteractionOperatorKind.ignore implies cf.oclIsKindOf(UML!ConsiderIgnoreFragment)
); 

helper context UML!CombinedFragment def: opt_loop_break_neg(): Boolean = 
  UML!CombinedFragment.allInstances()->forAll(cf |
    cf.interactionOperator = InteractionOperatorKind.opt or cf.interactionOperator = InteractionOperatorKind.loop or cf.interactionOperator = InteractionOperatorKind.break or cf.interactionOperator = InteractionOperatorKind.assert or cf.interactionOperator = InteractionOperatorKind.neg implies cf.operand->size() = 1
); 

helper context UML!CommunicationPath def: association_ends(): Boolean = 
  UML!CommunicationPath.allInstances()->forAll(cp |
    cp.endType->forAll(t| 
      t.oclIsKindOf(UML!DeploymentTarget))
); 

helper context UML!Component def: no_nested_classifiers(): Boolean = 
  UML!Component.allInstances()->forAll(c |
    c.nestedClassifier->isEmpty()
); 

helper context UML!Component def: no_packaged_elements(): Boolean = 
  UML!Component.allInstances()->forAll(c |
    c.nestedClassifier <> OclUndefined implies c.packagedElement->isEmpty()
); 

helper context UML!ConditionalNode def: result_no_incoming(): Boolean = 
  UML!ConditionalNode.allInstances()->forAll(cn |
    cn.result->collect(op| 
      op.incoming)->isEmpty()
); 

helper context UML!ConditionalNode def: no_input_pins(): Boolean = 
  UML!ConditionalNode.allInstances()->forAll(cn |
    cn.input->isEmpty()
); 

helper context UML!ConditionalNode def: one_clause_with_executable_node(): Boolean = 
  UML!ConditionalNode.allInstances()->forAll(cn |
    cn.node->select(an| 
      an.oclIsKindOf(UML!ExecutableNode))->collect(an| 
      an.oclAsType(UML!ExecutableNode))->forAll(n| 
      cn.clause->select(c| 
        c.test.()->includes(n))->size() = 1)
); 

helper context UML!ConditionalNode def: matching_output_pins(): Boolean = 
  UML!ConditionalNode.allInstances()->forAll(cn |
    cn.clause->forAll(c| 
      c.bodyOutput->size() = cn.result->size() and Sequence{}->forAll(i| 
        c.bodyOutput->at(i).type.conformsTo(cn.result->at(i).type) and c.bodyOutput->at(i).isOrdered = cn.result->at(i).isOrdered and c.bodyOutput->at(i).isUnique = cn.result->at(i).isUnique and c.bodyOutput->at(i).compatibleWith(cn.result->at(i))))
); 

helper context UML!ConditionalNode def: executable_nodes(): Boolean = 
  UML!ConditionalNode.allInstances()->forAll(cn |
    cn.clause->collect(c| 
      c.test).() = cn.node->select(an| 
      an.oclIsKindOf(UML!ExecutableNode))->collect(an| 
      an.oclAsType(UML!ExecutableNode))
); 

helper context UML!ConditionalNode def: clause_no_predecessor(): Boolean = 
  UML!ConditionalNode.allInstances()->forAll(cn |
    cn.clause->closure(c| 
      c.predecessorClause)->intersection(cn.clause)->isEmpty()
); 

helper context UML!ConnectionPointReference def: exit_pseudostates(): Boolean = 
  UML!ConnectionPointReference.allInstances()->forAll(cpr |
    cpr.exit->forAll(p| 
      p.kind = PseudostateKind.exitPoint)
); 

helper context UML!ConnectionPointReference def: entry_pseudostates(): Boolean = 
  UML!ConnectionPointReference.allInstances()->forAll(cpr |
    cpr.entry->forAll(p| 
      p.kind = PseudostateKind.entryPoint)
); 

helper context UML!Connector def: types(): Boolean = 
  UML!Connector.allInstances()->forAll(c |
    c.type <> OclUndefined implies let noOfEnds : Integer = 
      c.end->size() in 
        c.type.memberEnd->size() = noOfEnds and Sequence{}->forAll(i| 
          c.end->at(i).role.type.conformsTo(c.type.memberEnd->at(i).type))
); 

helper context UML!Connector def: roles(): Boolean = 
  UML!Connector.allInstances()->forAll(c |
    c.ownedConnector <> OclUndefined and c.end->forAll(e| 
      c.ownedConnector.allRoles()->includes(e.role) or e.role.oclIsKindOf(UML!Port) and c.ownedConnector.allRoles()->includes(e.partWithPort))
); 

helper context UML!ConnectorEnd def: role_and_part_with_port(): Boolean = 
  UML!ConnectorEnd.allInstances()->forAll(ce |
    ce.partWithPort->oclAsSet()->notEmpty() implies ce.role.oclIsKindOf(UML!Port) and ce.partWithPort.type.oclAsType(UML!Namespace).member->includes(ce.role)
); 

helper context UML!ConnectorEnd def: part_with_port_empty(): Boolean = 
  UML!ConnectorEnd.allInstances()->forAll(ce |
    ce.role.oclIsKindOf(UML!Port) and ce.role.owner = ce.end.owner implies ce.partWithPort->oclAsSet()->isEmpty()
); 

helper context UML!ConnectorEnd def: multiplicity(): Boolean = 
  UML!ConnectorEnd.allInstances()->forAll(ce |
    ce.compatibleWith(ce.definingEnd)
); 

helper context UML!ConnectorEnd def: self_part_with_port(): Boolean = 
  UML!ConnectorEnd.allInstances()->forAll(ce |
    ce.partWithPort->oclAsSet()->notEmpty() implies not(ce.partWithPort.oclIsKindOf(UML!Port))
); 

helper context UML!ConsiderIgnoreFragment def: consider_or_ignore(): Boolean = 
  UML!ConsiderIgnoreFragment.allInstances()->forAll(cif |
    cif.interactionOperator = InteractionOperatorKind.consider or cif.interactionOperator = InteractionOperatorKind.ignore
); 

helper context UML!ConsiderIgnoreFragment def: type(): Boolean = 
  UML!ConsiderIgnoreFragment.allInstances()->forAll(cif |
    cif.message->forAll(m| 
      m.oclIsKindOf(UML!Operation) or m.oclIsKindOf(UML!Signal))
); 

helper context UML!Constraint def: boolean_value(): Boolean = 
  UML!Constraint.allInstances()->forAll(c |
    OclUndefined
); 

helper context UML!Constraint def: no_side_effects(): Boolean = 
  UML!Constraint.allInstances()->forAll(c |
    OclUndefined
); 

helper context UML!Constraint def: not_apply_to_self(): Boolean = 
  UML!Constraint.allInstances()->forAll(c |
    not(c.constrainedElement->includes(c))
); 

helper context UML!Continuation def: first_or_last_interaction_fragment(): Boolean = 
  UML!Continuation.allInstances()->forAll(c |
    c.enclosingOperand->oclAsSet()->notEmpty() and let peerFragments : OrderedSet(UML!InteractionFragment) = 
      c.enclosingOperand.fragment in 
        peerFragments->notEmpty() and peerFragments->first() = c or peerFragments->last() = c
); 

helper context UML!Continuation def: same_name(): Boolean = 
  UML!Continuation.allInstances()->forAll(c |
    c.enclosingOperand.operand->oclAsSet()->notEmpty() and let parentInteraction : Set(UML!Interaction) = 
      c.enclosingOperand.operand->oclAsSet()->closure(cf| 
        cf.enclosingOperand.operand)->collect(cf| 
        cf.enclosingInteraction)->collect(i| 
        i.oclAsType(UML!Interaction))->asSet() in 
        parentInteraction->size() = 1 and let peerInteractions : Set(UML!Interaction) = 
          parentInteraction.()->asSet() in 
            peerInteractions->notEmpty() and let combinedFragments1 : Set(UML!CombinedFragment) = 
              peerInteractions->collect(i| 
                i.fragment)->select(if| 
                if.oclIsKindOf(UML!CombinedFragment))->collect(if| 
                if.oclAsType(UML!CombinedFragment))->asSet() in 
                combinedFragments1->notEmpty() and combinedFragments1->closure(cf| 
                  cf.operand->collect(io| 
                    io.fragment)->select(if| 
                    if.oclIsKindOf(UML!CombinedFragment))->collect(if| 
                    if.oclAsType(UML!CombinedFragment)))->asSet()->collect(cf| 
                  cf.operand)->collect(io| 
                  io.fragment)->select(if| 
                  if.oclIsKindOf(UML!Continuation))->collect(if| 
                  if.oclAsType(UML!Continuation))->asSet()->forAll(c| 
                  c.name = c.name implies c.covered->asSet()->forAll(cl| 
                    c.covered->asSet()->select(l| 
                      l.represents = cl.represents and l.selector = cl.selector)->asSet()->size() = 1) and c.covered->asSet()->forAll(cl| 
                    c.covered->asSet()->select(l| 
                      l.represents = cl.represents and l.selector = cl.selector)->asSet()->size() = 1))
); 

helper context UML!Continuation def: global(): Boolean = 
  UML!Continuation.allInstances()->forAll(c |
    c.enclosingOperand->oclAsSet()->notEmpty() and let operandLifelines : Set(UML!Lifeline) = 
      c.enclosingOperand.covered in 
        operandLifelines->notEmpty() and operandLifelines->forAll(ol| 
          c.covered->includes(ol))
); 

helper context UML!ControlFlow def: object_nodes(): Boolean = 
  UML!ControlFlow.allInstances()->forAll(cf |
    cf.source.oclIsKindOf(UML!ObjectNode) implies cf.source.oclAsType(UML!ObjectNode).isControlType and cf.target.oclIsKindOf(UML!ObjectNode) implies cf.target.oclAsType(UML!ObjectNode).isControlType
); 

helper context UML!CreateLinkAction def: association_not_abstract(): Boolean = 
  UML!CreateLinkAction.allInstances()->forAll(cla |
    not(cla.association().isAbstract)
); 

helper context UML!CreateLinkObjectAction def: multiplicity(): Boolean = 
  UML!CreateLinkObjectAction.allInstances()->forAll(cloa |
    cloa.result->is(1,1.toUnlimitedNatural())
); 

helper context UML!CreateLinkObjectAction def: type_of_result(): Boolean = 
  UML!CreateLinkObjectAction.allInstances()->forAll(cloa |
    cloa.result.type = cloa.association()
); 

helper context UML!CreateLinkObjectAction def: association_class(): Boolean = 
  UML!CreateLinkObjectAction.allInstances()->forAll(cloa |
    cloa.association().oclIsKindOf(UML!AssociationClass)
); 

helper context UML!CreateObjectAction def: classifier_not_abstract(): Boolean = 
  UML!CreateObjectAction.allInstances()->forAll(coa |
    not(coa.classifier.isAbstract)
); 

helper context UML!CreateObjectAction def: multiplicity(): Boolean = 
  UML!CreateObjectAction.allInstances()->forAll(coa |
    coa.result->is(1,1.toUnlimitedNatural())
); 

helper context UML!CreateObjectAction def: classifier_not_association_class(): Boolean = 
  UML!CreateObjectAction.allInstances()->forAll(coa |
    not(coa.classifier.oclIsKindOf(UML!AssociationClass))
); 

helper context UML!CreateObjectAction def: same_type(): Boolean = 
  UML!CreateObjectAction.allInstances()->forAll(coa |
    coa.result.type = coa.classifier
); 

helper context UML!DecisionNode def: zero_input_parameters(): Boolean = 
  UML!DecisionNode.allInstances()->forAll(dn |
    dn.decisionInput <> OclUndefined and dn.decisionInputFlow = OclUndefined and dn.incoming->exists(ae| 
      ae.oclIsKindOf(UML!ControlFlow)) implies dn.decisionInput.inputParameters()->isEmpty()
); 

helper context UML!DecisionNode def: edges(): Boolean = 
  UML!DecisionNode.allInstances()->forAll(dn |
    let allEdges : Set(UML!ActivityEdge) = 
      dn.incoming.() in 
        let allRelevantEdges : Set(UML!ActivityEdge) = 
          if (dn.decisionInputFlow->oclAsSet()->notEmpty()) then 
            allEdges->excluding(dn.decisionInputFlow)
          else 
            allEdges
          endif in 
            allRelevantEdges->forAll(ae| 
              ae.oclIsKindOf(UML!ControlFlow)) or allRelevantEdges->forAll(ae| 
              ae.oclIsKindOf(UML!ObjectFlow))
); 

helper context UML!DecisionNode def: decision_input_flow_incoming(): Boolean = 
  UML!DecisionNode.allInstances()->forAll(dn |
    dn.incoming->includes(dn.decisionInputFlow)
); 

helper context UML!DecisionNode def: two_input_parameters(): Boolean = 
  UML!DecisionNode.allInstances()->forAll(dn |
    dn.decisionInput <> OclUndefined and dn.decisionInputFlow <> OclUndefined and dn.incoming->forAll(ae| 
      ae.oclIsKindOf(UML!ObjectFlow)) implies dn.decisionInput.inputParameters()->size() = 2
); 

helper context UML!DecisionNode def: incoming_outgoing_edges(): Boolean = 
  UML!DecisionNode.allInstances()->forAll(dn |
    dn.incoming->size() = 1 or dn.incoming->size() = 2 and dn.outgoing->size() > 0
); 

helper context UML!DecisionNode def: incoming_control_one_input_parameter(): Boolean = 
  UML!DecisionNode.allInstances()->forAll(dn |
    dn.decisionInput <> OclUndefined and dn.decisionInputFlow <> OclUndefined and dn.incoming->exists(ae| 
      ae.oclIsKindOf(UML!ControlFlow)) implies dn.decisionInput.inputParameters()->size() = 1
); 

helper context UML!DecisionNode def: parameters(): Boolean = 
  UML!DecisionNode.allInstances()->forAll(dn |
    dn.decisionInput <> OclUndefined implies dn.decisionInput.ownedParameter->forAll(par| 
      par.direction <> ParameterDirectionKind.out and par.direction <> ParameterDirectionKind.inout) and dn.decisionInput.ownedParameter->one(par| 
      par.direction <> ParameterDirectionKind.return)
); 

helper context UML!DecisionNode def: incoming_object_one_input_parameter(): Boolean = 
  UML!DecisionNode.allInstances()->forAll(dn |
    dn.decisionInput <> OclUndefined and dn.decisionInputFlow = OclUndefined and dn.incoming->forAll(ae| 
      ae.oclIsKindOf(UML!ObjectFlow)) implies dn.decisionInput.inputParameters()->size() = 1
); 

helper context UML!DeploymentSpecification def: deployment_target(): Boolean = 
  UML!DeploymentSpecification.allInstances()->forAll(ds |
    ds.deployment->oclAsSet()->forAll(d| 
      d.location.oclIsKindOf(UML!ExecutionEnvironment))
); 

helper context UML!DeploymentSpecification def: deployed_elements(): Boolean = 
  UML!DeploymentSpecification.allInstances()->forAll(ds |
    ds.deployment->oclAsSet()->forAll(d| 
      d.location.deployedElement->forAll(pe| 
        pe.oclIsKindOf(UML!Component)))
); 

helper context UML!DestroyObjectAction def: multiplicity(): Boolean = 
  UML!DestroyObjectAction.allInstances()->forAll(doa |
    doa.target->is(1,1.toUnlimitedNatural())
); 

helper context UML!DestroyObjectAction def: no_type(): Boolean = 
  UML!DestroyObjectAction.allInstances()->forAll(doa |
    doa.target.type = OclUndefined
); 

helper context UML!DestructionOccurrenceSpecification def: no_occurrence_specifications_below(): Boolean = 
  UML!DestructionOccurrenceSpecification.allInstances()->forAll(dos |
    let o : UML!InteractionOperand = 
      dos.enclosingOperand in 
        o->oclAsSet()->notEmpty() and let peerEvents : OrderedSet(UML!OccurrenceSpecification) = 
          dos.covered.covered->select(os| 
            os.enclosingOperand = o) in 
            peerEvents->last() = dos
); 

helper context UML!Duration def: no_expr_requires_observation(): Boolean = 
  UML!Duration.allInstances()->forAll(d |
    d.expr = OclUndefined implies d.observation->size() = 1 and d.observation->forAll(o| 
      o.oclIsKindOf(UML!DurationObservation))
); 

helper context UML!DurationConstraint def: first_event_multiplicity(): Boolean = 
  UML!DurationConstraint.allInstances()->forAll(dc |
    if (dc.constrainedElement->size() = 2) then 
      dc.firstEvent->size() = 2
    else 
      dc.firstEvent->size() = 0
    endif
); 

helper context UML!DurationConstraint def: has_one_or_two_constrainedElements(): Boolean = 
  UML!DurationConstraint.allInstances()->forAll(dc |
    dc.constrainedElement->size() = 1 or dc.constrainedElement->size() = 2
); 

helper context UML!DurationObservation def: first_event_multiplicity(): Boolean = 
  UML!DurationObservation.allInstances()->forAll(do |
    if (do.event->size() = 2) then 
      do.firstEvent->size() = 2
    else 
      do.firstEvent->size() = 0
    endif
); 

helper context UML!Element def: has_owner(): Boolean = 
  UML!Element.allInstances()->forAll(e |
    e.mustBeOwned() implies e.owner->oclAsSet()->notEmpty()
); 

helper context UML!Element def: not_own_self(): Boolean = 
  UML!Element.allInstances()->forAll(e |
    not(e.allOwnedElements()->includes(e))
); 

helper context UML!ElementImport def: imported_element_is_public(): Boolean = 
  UML!ElementImport.allInstances()->forAll(ei |
    ei.importedElement.visibility <> OclUndefined implies ei.importedElement.visibility = VisibilityKind.public
); 

helper context UML!ElementImport def: visibility_public_or_private(): Boolean = 
  UML!ElementImport.allInstances()->forAll(ei |
    ei.visibility = VisibilityKind.public or ei.visibility = VisibilityKind.private
); 

helper context UML!Enumeration def: immutable(): Boolean = 
  UML!Enumeration.allInstances()->forAll(e |
    e.ownedAttribute->forAll(p| 
      p.isReadOnly)
); 

helper context UML!ExceptionHandler def: handler_body_edges(): Boolean = 
  UML!ExceptionHandler.allInstances()->forAll(eh |
    eh.handlerBody.incoming->isEmpty() and eh.handlerBody.outgoing->isEmpty() and eh.exceptionInput.incoming->isEmpty()
); 

helper context UML!ExceptionHandler def: output_pins(): Boolean = 
  UML!ExceptionHandler.allInstances()->forAll(eh |
    eh.protectedNode.oclIsKindOf(UML!Action) and eh.protectedNode.oclAsType(UML!Action).output->notEmpty() implies eh.handlerBody.oclIsKindOf(UML!Action) and let protectedNodeOutput : OrderedSet(UML!OutputPin) = 
      eh.protectedNode.oclAsType(UML!Action).output in 
        let handlerBodyOutput : OrderedSet(UML!OutputPin) = 
          eh.handlerBody.oclAsType(UML!Action).output in 
            protectedNodeOutput->size() = handlerBodyOutput->size() and Sequence{}->forAll(i| 
              handlerBodyOutput->at(i).type.conformsTo(protectedNodeOutput->at(i).type) and handlerBodyOutput->at(i).isOrdered = protectedNodeOutput->at(i).isOrdered and handlerBodyOutput->at(i).compatibleWith(protectedNodeOutput->at(i)))
); 

helper context UML!ExceptionHandler def: one_input(): Boolean = 
  UML!ExceptionHandler.allInstances()->forAll(eh |
    eh.handlerBody.oclIsKindOf(UML!Action) and let inputs : OrderedSet(UML!InputPin) = 
      eh.handlerBody.oclAsType(UML!Action).input in 
        inputs->size() = 1 and inputs->first() = eh.exceptionInput
); 

helper context UML!ExceptionHandler def: edge_source_target(): Boolean = 
  UML!ExceptionHandler.allInstances()->forAll(eh |
    let nodes : Set(UML!ActivityNode) = 
      eh.handlerBody.oclAsType(UML!Action).allOwnedNodes() in 
        nodes->collect(an| 
          an.outgoing)->forAll(ae| 
          nodes->includes(ae.target)) and nodes->collect(an| 
          an.incoming)->forAll(ae| 
          nodes->includes(ae.source))
); 

helper context UML!ExceptionHandler def: handler_body_owner(): Boolean = 
  UML!ExceptionHandler.allInstances()->forAll(eh |
    eh.handlerBody.owner = eh.protectedNode.owner
); 

helper context UML!ExceptionHandler def: exception_input_type(): Boolean = 
  UML!ExceptionHandler.allInstances()->forAll(eh |
    eh.exceptionInput.type = OclUndefined or eh.exceptionType->forAll(c| 
      c.conformsTo(eh.exceptionInput.type.oclAsType(UML!Classifier)))
); 

helper context UML!ExecutionSpecification def: same_lifeline(): Boolean = 
  UML!ExecutionSpecification.allInstances()->forAll(es |
    es.start.covered = es.finish.covered
); 

helper context UML!ExpansionNode def: region_as_input_or_output(): Boolean = 
  UML!ExpansionNode.allInstances()->forAll(en |
    en.regionAsInput->oclAsSet()->notEmpty()->xor()
); 

helper context UML!Extend def: extension_points(): Boolean = 
  UML!Extend.allInstances()->forAll(e |
    e.extensionLocation->forAll(xp| 
      e.extendedCase.extensionPoint->includes(xp))
); 

helper context UML!Extension def: non_owned_end(): Boolean = 
  UML!Extension.allInstances()->forAll(e |
    e.metaclassEnd()->oclAsSet()->notEmpty() and e.metaclassEnd().type.oclIsKindOf(UML!Class)
); 

helper context UML!Extension def: is_binary(): Boolean = 
  UML!Extension.allInstances()->forAll(e |
    e.memberEnd->size() = 2
); 

helper context UML!ExtensionEnd def: multiplicity(): Boolean = 
  UML!ExtensionEnd.allInstances()->forAll(ee |
    ee.lowerBound() = 0 or ee.lowerBound() = 1 and ee.upperBound() = 1
); 

helper context UML!ExtensionEnd def: aggregation(): Boolean = 
  UML!ExtensionEnd.allInstances()->forAll(ee |
    ee.aggregation = AggregationKind.composite
); 

helper context UML!ExtensionPoint def: must_have_name(): Boolean = 
  UML!ExtensionPoint.allInstances()->forAll(ep |
    ep.name->oclAsSet()->notEmpty()
); 

helper context UML!FinalNode def: no_outgoing_edges(): Boolean = 
  UML!FinalNode.allInstances()->forAll(fn |
    fn.outgoing->isEmpty()
); 

helper context UML!FinalState def: no_exit_behavior(): Boolean = 
  UML!FinalState.allInstances()->forAll(fs |
    fs.exit->oclAsSet()->isEmpty()
); 

helper context UML!FinalState def: no_outgoing_transitions(): Boolean = 
  UML!FinalState.allInstances()->forAll(fs |
    fs.outgoing->size() = 0
); 

helper context UML!FinalState def: no_regions(): Boolean = 
  UML!FinalState.allInstances()->forAll(fs |
    fs.region->size() = 0
); 

helper context UML!FinalState def: cannot_reference_submachine(): Boolean = 
  UML!FinalState.allInstances()->forAll(fs |
    fs.submachine->oclAsSet()->isEmpty()
); 

helper context UML!FinalState def: no_entry_behavior(): Boolean = 
  UML!FinalState.allInstances()->forAll(fs |
    fs.entry->oclAsSet()->isEmpty()
); 

helper context UML!FinalState def: no_state_behavior(): Boolean = 
  UML!FinalState.allInstances()->forAll(fs |
    fs.doActivity->oclAsSet()->isEmpty()
); 

helper context UML!ForkNode def: edges(): Boolean = 
  UML!ForkNode.allInstances()->forAll(fn |
    let allEdges : Set(UML!ActivityEdge) = 
      fn.incoming.() in 
        allEdges->forAll(ae| 
          ae.oclIsKindOf(UML!ControlFlow)) or allEdges->forAll(ae| 
          ae.oclIsKindOf(UML!ObjectFlow))
); 

helper context UML!ForkNode def: one_incoming_edge(): Boolean = 
  UML!ForkNode.allInstances()->forAll(fn |
    fn.incoming->size() = 1
); 

helper context UML!FunctionBehavior def: one_output_parameter(): Boolean = 
  UML!FunctionBehavior.allInstances()->forAll(fb |
    fb.ownedParameter->select(p| 
      p.direction = ParameterDirectionKind.out or p.direction = ParameterDirectionKind.inout or p.direction = ParameterDirectionKind.return)->size() >= 1
); 

helper context UML!FunctionBehavior def: types_of_parameters(): Boolean = 
  UML!FunctionBehavior.allInstances()->forAll(fb |
    fb.ownedParameter->forAll(p| 
      p.type <> OclUndefined and p.type.oclIsTypeOf(UML!DataType) and fb.hasAllDataTypeAttributes(p.type.oclAsType(UML!DataType)))
); 

helper context UML!Gate def: actual_gate_matched(): Boolean = 
  UML!Gate.allInstances()->forAll(g |
    g.actualGate->oclAsSet()->notEmpty() implies g.actualGate.refersTo.formalGate->select(g| 
      g.matches(g))->size() = 1
); 

helper context UML!Gate def: inside_cf_matched(): Boolean = 
  UML!Gate.allInstances()->forAll(g |
    g.isInsideCF() implies g.cfragmentGate.cfragmentGate->select(g| 
      g.isOutsideCF() and g.matches(g))->size() = 1
); 

helper context UML!Gate def: outside_cf_matched(): Boolean = 
  UML!Gate.allInstances()->forAll(g |
    g.isOutsideCF() implies if (g.cfragmentGate.interactionOperator->oclAsSet()->asOrderedSet()->first() = InteractionOperatorKind.alt) then 
      g.cfragmentGate.operand->forAll(op| 
        g.cfragmentGate.cfragmentGate->select(g| 
          g.isInsideCF() and g.oppositeEnd()->collect(me| 
            me.enclosingFragment())->includes(g.cfragmentGate) and g.matches(g))->size() = 1)
    else 
      g.cfragmentGate.cfragmentGate->select(g| 
        g.isInsideCF() and g.matches(g))->size() = 1
    endif
); 

helper context UML!Gate def: formal_gate_distinguishable(): Boolean = 
  UML!Gate.allInstances()->forAll(g |
    g.isFormal() implies g.formalGate.formalGate->select(g| 
      g.getName() = g.getName())->size() = 1
); 

helper context UML!Gate def: actual_gate_distinguishable(): Boolean = 
  UML!Gate.allInstances()->forAll(g |
    g.isActual() implies g.actualGate.actualGate->select(g| 
      g.getName() = g.getName())->size() = 1
); 

helper context UML!Gate def: outside_cf_gate_distinguishable(): Boolean = 
  UML!Gate.allInstances()->forAll(g |
    g.isOutsideCF() implies g.cfragmentGate.cfragmentGate->select(g| 
      g.getName() = g.getName())->size() = 1
); 

helper context UML!Gate def: inside_cf_gate_distinguishable(): Boolean = 
  UML!Gate.allInstances()->forAll(g |
    g.isInsideCF() implies let selfOperand : UML!InteractionOperand = 
      g.getOperand() in 
        g.cfragmentGate.cfragmentGate->select(g| 
          g.isInsideCF() and g.getName() = g.getName())->select(g| 
          g.getOperand() = selfOperand)->size() = 1
); 

helper context UML!GeneralOrdering def: irreflexive_transitive_closure(): Boolean = 
  UML!GeneralOrdering.allInstances()->forAll(go |
    go.after->oclAsSet()->closure(os| 
      os.toAfter->collect(go| 
        go.after))->excludes(go.before)
); 

helper context UML!GeneralizationSet def: generalization_same_classifier(): Boolean = 
  UML!GeneralizationSet.allInstances()->forAll(gs |
    gs.generalization->collect(g| 
      g.general)->asSet()->size() <= 1
); 

helper context UML!GeneralizationSet def: maps_to_generalization_set(): Boolean = 
  UML!GeneralizationSet.allInstances()->forAll(gs |
    gs.powertype <> OclUndefined implies gs.generalization->forAll(gen| 
      not(gen.general = gs.powertype) and not(gen.general.allParents()->includes(gs.powertype)) and not(gen.specific = gs.powertype) and not(gs.powertype.allParents()->includes(gen.specific)))
); 

helper context UML!InformationFlow def: must_conform(): Boolean = 
  UML!InformationFlow.allInstances()->forAll(if |
    OclUndefined
); 

helper context UML!InformationFlow def: sources_and_targets_kind(): Boolean = 
  UML!InformationFlow.allInstances()->forAll(if |
    if.informationSource->forAll(sis| 
      if.oclIsKindOf(UML!Actor) or if.oclIsKindOf(UML!Node) or if.oclIsKindOf(UML!UseCase) or if.oclIsKindOf(UML!Artifact) or if.oclIsKindOf(UML!Class) or if.oclIsKindOf(UML!Component) or if.oclIsKindOf(UML!Port) or if.oclIsKindOf(UML!Property) or if.oclIsKindOf(UML!Interface) or if.oclIsKindOf(UML!Package) or if.oclIsKindOf(UML!ActivityNode) or if.oclIsKindOf(UML!ActivityPartition) or if.oclIsKindOf(UML!InstanceSpecification) and not(sis.oclAsType(UML!InstanceSpecification).classifier->exists(c| 
        c.oclIsKindOf(UML!Relationship)))) and if.informationTarget->forAll(sit| 
      if.oclIsKindOf(UML!Actor) or if.oclIsKindOf(UML!Node) or if.oclIsKindOf(UML!UseCase) or if.oclIsKindOf(UML!Artifact) or if.oclIsKindOf(UML!Class) or if.oclIsKindOf(UML!Component) or if.oclIsKindOf(UML!Port) or if.oclIsKindOf(UML!Property) or if.oclIsKindOf(UML!Interface) or if.oclIsKindOf(UML!Package) or if.oclIsKindOf(UML!ActivityNode) or if.oclIsKindOf(UML!ActivityPartition) or if.oclIsKindOf(UML!InstanceSpecification) and not(sit.oclAsType(UML!InstanceSpecification).classifier->exists(c| 
        c.oclIsKindOf(UML!Relationship))))
); 

helper context UML!InformationFlow def: convey_classifiers(): Boolean = 
  UML!InformationFlow.allInstances()->forAll(if |
    if.conveyed->forAll(c| 
      c.oclIsKindOf(UML!Class) or c.oclIsKindOf(UML!Interface) or c.oclIsKindOf(UML!InformationItem) or c.oclIsKindOf(UML!Signal) or c.oclIsKindOf(UML!Component))
); 

helper context UML!InformationItem def: sources_and_targets(): Boolean = 
  UML!InformationItem.allInstances()->forAll(ii |
    ii.represented->select(c| 
      c.oclIsKindOf(UML!InformationItem))->forAll(p| 
      p.conveyed->collect(if| 
        if.source)->forAll(q| 
        ii.conveyed->collect(if| 
          if.source)->includes(q)) and p.conveyed->collect(if| 
        if.target)->forAll(q| 
        ii.conveyed->collect(if| 
          if.target)->includes(q))) and ii.represented->forAll(c| 
      c.oclIsKindOf(UML!Class) or c.oclIsKindOf(UML!Interface) or c.oclIsKindOf(UML!InformationItem) or c.oclIsKindOf(UML!Signal) or c.oclIsKindOf(UML!Component))
); 

helper context UML!InformationItem def: has_no(): Boolean = 
  UML!InformationItem.allInstances()->forAll(ii |
    ii.generalization->isEmpty() and ii.feature->isEmpty()
); 

helper context UML!InformationItem def: not_instantiable(): Boolean = 
  UML!InformationItem.allInstances()->forAll(ii |
    ii.isAbstract
); 

helper context UML!InitialNode def: no_incoming_edges(): Boolean = 
  UML!InitialNode.allInstances()->forAll(in |
    in.incoming->isEmpty()
); 

helper context UML!InitialNode def: control_edges(): Boolean = 
  UML!InitialNode.allInstances()->forAll(in |
    in.outgoing->forAll(ae| 
      ae.oclIsKindOf(UML!ControlFlow))
); 

helper context UML!InputPin def: outgoing_edges_structured_only(): Boolean = 
  UML!InputPin.allInstances()->forAll(ip |
    ip.outgoing->notEmpty() implies ip.input <> OclUndefined and ip.input.oclIsKindOf(UML!StructuredActivityNode) and ip.input.oclAsType(UML!StructuredActivityNode).allOwnedNodes()->includesAll(ip.outgoing->collect(ae| 
      ae.target))
); 

helper context UML!InstanceSpecification def: deployment_artifact(): Boolean = 
  UML!InstanceSpecification.allInstances()->forAll(is |
    is.deployedArtifact->notEmpty() implies is.classifier->exists(c| 
      c.oclIsKindOf(UML!Artifact))
); 

helper context UML!InstanceSpecification def: structural_feature(): Boolean = 
  UML!InstanceSpecification.allInstances()->forAll(is |
    is.classifier->forAll(c| 
      c.allSlottableFeatures()->forAll(f| 
        is.slot->select(s| 
          s.definingFeature = f)->size() <= 1))
); 

helper context UML!InstanceSpecification def: defining_feature(): Boolean = 
  UML!InstanceSpecification.allInstances()->forAll(is |
    is.slot->forAll(s| 
      is.classifier->exists(c| 
        c.allSlottableFeatures()->includes(s.definingFeature)))
); 

helper context UML!InstanceSpecification def: deployment_target(): Boolean = 
  UML!InstanceSpecification.allInstances()->forAll(is |
    is.deployment->notEmpty() implies is.classifier->exists(node| 
      node.oclIsKindOf(UML!Node) and UML!Node->allInstances()->exists(n| 
        n.part->exists(p| 
          p.type = node)))
); 

helper context UML!Interaction def: not_contained(): Boolean = 
  UML!Interaction.allInstances()->forAll(i |
    i.enclosingInteraction->oclAsSet()->isEmpty()
); 

helper context UML!InteractionConstraint def: minint_maxint(): Boolean = 
  UML!InteractionConstraint.allInstances()->forAll(ic |
    ic.maxint->oclAsSet()->notEmpty() or ic.minint->oclAsSet()->notEmpty() implies ic.guard.operand.interactionOperator = InteractionOperatorKind.loop
); 

helper context UML!InteractionConstraint def: minint_non_negative(): Boolean = 
  UML!InteractionConstraint.allInstances()->forAll(ic |
    ic.minint->oclAsSet()->notEmpty() implies ic.minint->oclAsSet()->asSequence()->first().integerValue() >= 0
); 

helper context UML!InteractionConstraint def: maxint_positive(): Boolean = 
  UML!InteractionConstraint.allInstances()->forAll(ic |
    ic.maxint->oclAsSet()->notEmpty() implies ic.maxint->oclAsSet()->asSequence()->first().integerValue() > 0
); 

helper context UML!InteractionConstraint def: dynamic_variables(): Boolean = 
  UML!InteractionConstraint.allInstances()->forAll(ic |
    OclUndefined
); 

helper context UML!InteractionConstraint def: global_data(): Boolean = 
  UML!InteractionConstraint.allInstances()->forAll(ic |
    OclUndefined
); 

helper context UML!InteractionConstraint def: maxint_greater_equal_minint(): Boolean = 
  UML!InteractionConstraint.allInstances()->forAll(ic |
    ic.maxint->oclAsSet()->notEmpty() implies ic.minint->oclAsSet()->notEmpty() and ic.maxint->oclAsSet()->asSequence()->first().integerValue() >= ic.minint->oclAsSet()->asSequence()->first().integerValue()
); 

helper context UML!InteractionOperand def: guard_contain_references(): Boolean = 
  UML!InteractionOperand.allInstances()->forAll(io |
    OclUndefined
); 

helper context UML!InteractionOperand def: guard_directly_prior(): Boolean = 
  UML!InteractionOperand.allInstances()->forAll(io |
    OclUndefined
); 

helper context UML!InteractionUse def: gates_match(): Boolean = 
  UML!InteractionUse.allInstances()->forAll(iu |
    iu.actualGate->notEmpty() implies iu.refersTo.formalGate->forAll(fg| 
      iu.actualGate->select(g| 
        g.matches(fg))->size() = 1) and iu.actualGate->forAll(ag| 
      iu.refersTo.formalGate->select(g| 
        g.matches(ag))->size() = 1)
); 

helper context UML!InteractionUse def: arguments_are_constants(): Boolean = 
  UML!InteractionUse.allInstances()->forAll(iu |
    OclUndefined
); 

helper context UML!InteractionUse def: returnValueRecipient_coverage(): Boolean = 
  UML!InteractionUse.allInstances()->forAll(iu |
    iu.returnValueRecipient->oclAsSet()->asSet()->notEmpty() implies let covCE : Set(UML!ConnectableElement) = 
      iu.covered->collect(l| 
        l.represents)->asSet() in 
        covCE->notEmpty() and let classes : Set(UML!Classifier) = 
          covCE->collect(ce| 
            ce.type)->collect(t| 
            t.oclIsKindOf(UML!Classifier))->collect(b| 
            b.oclAsType(UML!Classifier))->asSet() in 
            let allProps : Set(UML!Property) = 
              classes->collect(c| 
                c.attribute).()->asSet() in 
                allProps->includes(iu.returnValueRecipient)
); 

helper context UML!InteractionUse def: arguments_correspond_to_parameters(): Boolean = 
  UML!InteractionUse.allInstances()->forAll(iu |
    OclUndefined
); 

helper context UML!InteractionUse def: returnValue_type_recipient_correspondence(): Boolean = 
  UML!InteractionUse.allInstances()->forAll(iu |
    iu.returnValue.type->oclAsSet()->asSequence()->notEmpty() implies iu.returnValue.type->oclAsSet()->asSequence()->first() = iu.returnValueRecipient.type->oclAsSet()->asSequence()->first()
); 

helper context UML!InteractionUse def: all_lifelines(): Boolean = 
  UML!InteractionUse.allInstances()->forAll(iu |
    let parentInteraction : Set(UML!Interaction) = 
      iu.enclosingInteraction->oclAsSet()->asSet().() in 
        parentInteraction->size() = 1 and let refInteraction : UML!Interaction = 
          iu.refersTo in 
            parentInteraction->collect(i| 
              i.covered)->forAll(intLifeline| 
              refInteraction.covered->forAll(refLifeline| 
                refLifeline.represents = intLifeline.represents and refLifeline.selector.oclIsKindOf(UML!LiteralString) implies intLifeline.selector.oclIsKindOf(UML!LiteralString) and refLifeline.selector.oclAsType(UML!LiteralString).value = intLifeline.selector.oclAsType(UML!LiteralString).value and refLifeline.selector.oclIsKindOf(UML!LiteralInteger) implies intLifeline.selector.oclIsKindOf(UML!LiteralInteger) and refLifeline.selector.oclAsType(UML!LiteralInteger).value = intLifeline.selector.oclAsType(UML!LiteralInteger).value implies iu.covered->asSet()->includes(intLifeline)))
); 

helper context UML!Interface def: visibility(): Boolean = 
  UML!Interface.allInstances()->forAll(i |
    i.feature->forAll(f| 
      f.visibility = VisibilityKind.public)
); 

helper context UML!InterruptibleActivityRegion def: interrupting_edges(): Boolean = 
  UML!InterruptibleActivityRegion.allInstances()->forAll(iar |
    iar.interruptingEdge->forAll(edge| 
      iar.node->includes(edge.source) and iar.node->excludes(edge.target) and edge.target.containingActivity() = iar.inActivity)
); 

helper context UML!JoinNode def: one_outgoing_edge(): Boolean = 
  UML!JoinNode.allInstances()->forAll(jn |
    jn.outgoing->size() = 1
); 

helper context UML!JoinNode def: incoming_object_flow(): Boolean = 
  UML!JoinNode.allInstances()->forAll(jn |
    if (jn.incoming->exists(ae| 
      ae.oclIsKindOf(UML!ObjectFlow))) then 
      jn.outgoing->forAll(ae| 
        ae.oclIsKindOf(UML!ObjectFlow))
    else 
      jn.outgoing->forAll(ae| 
        ae.oclIsKindOf(UML!ControlFlow))
    endif
); 

helper context UML!Lifeline def: selector_specified(): Boolean = 
  UML!Lifeline.allInstances()->forAll(l |
    l.selector->oclAsSet()->notEmpty() = l.represents.oclIsKindOf(UML!MultiplicityElement) and l.represents.oclAsType(UML!MultiplicityElement).isMultivalued()
); 

helper context UML!Lifeline def: interaction_uses_share_lifeline(): Boolean = 
  UML!Lifeline.allInstances()->forAll(l |
    let intUses : Set(UML!InteractionUse) = 
      l.interaction.refersTo in 
        intUses->forAll(iuse| 
          let usingInteraction : Set(UML!Interaction) = 
            iuse.enclosingInteraction->oclAsSet()->asSet().() in 
              let peerUses : Set(UML!InteractionUse) = 
                usingInteraction->collect(i| 
                  i.fragment)->select(if| 
                  if.oclIsKindOf(UML!InteractionUse))->collect(if| 
                  if.oclAsType(UML!InteractionUse))->asSet().()->excluding(iuse) in 
                  peerUses->forAll(peerUse| 
                    peerUse.refersTo.lifeline->forAll(l| 
                      l.represents = l.represents and l.selector.oclIsKindOf(UML!LiteralString) implies l.selector.oclIsKindOf(UML!LiteralString) and l.selector.oclAsType(UML!LiteralString).value = l.selector.oclAsType(UML!LiteralString).value and l.selector.oclIsKindOf(UML!LiteralInteger) implies l.selector.oclIsKindOf(UML!LiteralInteger) and l.selector.oclAsType(UML!LiteralInteger).value = l.selector.oclAsType(UML!LiteralInteger).value implies usingInteraction->collect(i| 
                        i.lifeline)->exists(l| 
                        l.represents = l.represents and l.selector.oclIsKindOf(UML!LiteralString) implies l.selector.oclIsKindOf(UML!LiteralString) and l.selector.oclAsType(UML!LiteralString).value = l.selector.oclAsType(UML!LiteralString).value and l.selector.oclIsKindOf(UML!LiteralInteger) implies l.selector.oclIsKindOf(UML!LiteralInteger) and l.selector.oclAsType(UML!LiteralInteger).value = l.selector.oclAsType(UML!LiteralInteger).value))))
); 

helper context UML!Lifeline def: same_classifier(): Boolean = 
  UML!Lifeline.allInstances()->forAll(l |
    l.represents.namespace->oclAsSet()->closure(n| 
      n.namespace)->includes(l.interaction.context)
); 

helper context UML!Lifeline def: selector_int_or_string(): Boolean = 
  UML!Lifeline.allInstances()->forAll(l |
    l.selector->oclAsSet()->notEmpty() implies l.selector.oclIsKindOf(UML!LiteralInteger) or l.selector.oclIsKindOf(UML!LiteralString)
); 

helper context UML!LinkAction def: same_pins(): Boolean = 
  UML!LinkAction.allInstances()->forAll(la |
    la.inputValue->asBag() = la.endData->collect(led| 
      led.allPins())
); 

helper context UML!LinkAction def: same_association(): Boolean = 
  UML!LinkAction.allInstances()->forAll(la |
    la.endData->collect(led| 
      led.end) = la.association().memberEnd->asBag()
); 

helper context UML!LinkAction def: not_static(): Boolean = 
  UML!LinkAction.allInstances()->forAll(la |
    la.endData->forAll(led| 
      not(led.end.isStatic))
); 

helper context UML!LinkEndCreationData def: insertAt_pin(): Boolean = 
  UML!LinkEndCreationData.allInstances()->forAll(lecd |
    if (not(lecd.end.isOrdered)) then 
      lecd.insertAt = OclUndefined
    else 
      not(lecd.isReplaceAll) = false implies lecd.insertAt <> OclUndefined and lecd.insertAt->oclAsSet()->forAll(ip| 
        ip.type = UnlimitedNatural and ip->is(1,1.toUnlimitedNatural()))
    endif
); 

helper context UML!LinkEndData def: same_type(): Boolean = 
  UML!LinkEndData.allInstances()->forAll(led |
    led.value <> OclUndefined implies led.value.type.conformsTo(led.end.type)
); 

helper context UML!LinkEndData def: multiplicity(): Boolean = 
  UML!LinkEndData.allInstances()->forAll(led |
    led.value <> OclUndefined implies led.value->is(1,1.toUnlimitedNatural())
); 

helper context UML!LinkEndData def: end_object_input_pin(): Boolean = 
  UML!LinkEndData.allInstances()->forAll(led |
    led.value->oclAsSet()->excludesAll(led.qualifier->collect(qv| 
      qv.value))
); 

helper context UML!LinkEndData def: property_is_association_end(): Boolean = 
  UML!LinkEndData.allInstances()->forAll(led |
    led.end.association <> OclUndefined
); 

helper context UML!LinkEndData def: qualifiers(): Boolean = 
  UML!LinkEndData.allInstances()->forAll(led |
    led.end.qualifier->includesAll(led.qualifier->collect(qv| 
      qv.qualifier))
); 

helper context UML!LinkEndDestructionData def: destroyAt_pin(): Boolean = 
  UML!LinkEndDestructionData.allInstances()->forAll(ledd |
    if (not(ledd.end.isOrdered) or ledd.end.isUnique or ledd.isDestroyDuplicates) then 
      ledd.destroyAt = OclUndefined
    else 
      ledd.destroyAt <> OclUndefined and ledd.destroyAt->oclAsSet()->forAll(ip| 
        ip.type = UnlimitedNatural and ip->is(1,1.toUnlimitedNatural()))
    endif
); 

helper context UML!LoopNode def: result_no_incoming(): Boolean = 
  UML!LoopNode.allInstances()->forAll(ln |
    ln.result->collect(op| 
      op.incoming)->isEmpty()
); 

helper context UML!LoopNode def: input_edges(): Boolean = 
  UML!LoopNode.allInstances()->forAll(ln |
    ln.loopVariableInput->collect(ip| 
      ip.outgoing)->isEmpty()
); 

helper context UML!LoopNode def: executable_nodes(): Boolean = 
  UML!LoopNode.allInstances()->forAll(ln |
    ln.setupPart.().() = ln.node->select(an| 
      an.oclIsKindOf(UML!ExecutableNode))->collect(an| 
      an.oclAsType(UML!ExecutableNode))->asSet()
); 

helper context UML!LoopNode def: body_output_pins(): Boolean = 
  UML!LoopNode.allInstances()->forAll(ln |
    ln.bodyPart->collect(en| 
      en.oclAsType(UML!Action))->collect(a| 
      a.allActions())->collect(a| 
      a.output)->includesAll(ln.bodyOutput)
); 

helper context UML!LoopNode def: setup_test_and_body(): Boolean = 
  UML!LoopNode.allInstances()->forAll(ln |
    ln.setupPart->intersection(ln.test)->isEmpty() and ln.setupPart->intersection(ln.bodyPart)->isEmpty() and ln.test->intersection(ln.bodyPart)->isEmpty()
); 

helper context UML!LoopNode def: matching_output_pins(): Boolean = 
  UML!LoopNode.allInstances()->forAll(ln |
    ln.bodyOutput->size() = ln.loopVariable->size() and Sequence{}->forAll(i| 
      ln.bodyOutput->at(i).type.conformsTo(ln.loopVariable->at(i).type) and ln.bodyOutput->at(i).isOrdered = ln.loopVariable->at(i).isOrdered and ln.bodyOutput->at(i).isUnique = ln.loopVariable->at(i).isUnique and ln.loopVariable->at(i).includesMultiplicity(ln.bodyOutput->at(i)))
); 

helper context UML!LoopNode def: matching_loop_variables(): Boolean = 
  UML!LoopNode.allInstances()->forAll(ln |
    ln.loopVariableInput->size() = ln.loopVariable->size() and ln.loopVariableInput->collect(ip| 
      ip.type) = ln.loopVariable->collect(op| 
      op.type) and ln.loopVariableInput->collect(ip| 
      ip.isUnique) = ln.loopVariable->collect(op| 
      op.isUnique) and ln.loopVariableInput->collect(ip| 
      ip.lower) = ln.loopVariable->collect(op| 
      op.lower) and ln.loopVariableInput->collect(ip| 
      ip.upper) = ln.loopVariable->collect(op| 
      op.upper)
); 

helper context UML!LoopNode def: matching_result_pins(): Boolean = 
  UML!LoopNode.allInstances()->forAll(ln |
    ln.result->size() = ln.loopVariable->size() and ln.result->collect(op| 
      op.type) = ln.loopVariable->collect(op| 
      op.type) and ln.result->collect(op| 
      op.isUnique) = ln.loopVariable->collect(op| 
      op.isUnique) and ln.result->collect(op| 
      op.lower) = ln.loopVariable->collect(op| 
      op.lower) and ln.result->collect(op| 
      op.upper) = ln.loopVariable->collect(op| 
      op.upper)
); 

helper context UML!LoopNode def: loop_variable_outgoing(): Boolean = 
  UML!LoopNode.allInstances()->forAll(ln |
    ln.allOwnedNodes()->includesAll(ln.loopVariable->collect(op| 
      op.outgoing)->collect(ae| 
      ae.target))
); 

helper context UML!MergeNode def: one_outgoing_edge(): Boolean = 
  UML!MergeNode.allInstances()->forAll(mn |
    mn.outgoing->size() = 1
); 

helper context UML!MergeNode def: edges(): Boolean = 
  UML!MergeNode.allInstances()->forAll(mn |
    let allEdges : Set(UML!ActivityEdge) = 
      mn.incoming.() in 
        allEdges->forAll(ae| 
          ae.oclIsKindOf(UML!ControlFlow)) or allEdges->forAll(ae| 
          ae.oclIsKindOf(UML!ObjectFlow))
); 

helper context UML!Message def: sending_receiving_message_event(): Boolean = 
  UML!Message.allInstances()->forAll(m |
    m.receiveEvent.oclIsKindOf(UML!MessageOccurrenceSpecification) implies let f : UML!Lifeline = 
      m.sendEvent->oclAsSet()->select(me| 
        me.oclIsKindOf(UML!MessageOccurrenceSpecification))->collect(me| 
        me.oclAsType(UML!MessageOccurrenceSpecification))->asOrderedSet()->first().covered in 
        f = m.receiveEvent->oclAsSet()->select(me| 
          me.oclIsKindOf(UML!MessageOccurrenceSpecification))->collect(me| 
          me.oclAsType(UML!MessageOccurrenceSpecification))->asOrderedSet()->first().covered implies f.covered.indexOf(m.sendEvent.oclAsType(UML!MessageOccurrenceSpecification)->oclAsSet()->asOrderedSet()->first()) < f.covered.indexOf(m.receiveEvent.oclAsType(UML!MessageOccurrenceSpecification)->oclAsSet()->asOrderedSet()->first())
); 

helper context UML!Message def: arguments(): Boolean = 
  UML!Message.allInstances()->forAll(m |
    OclUndefined
); 

helper context UML!Message def: cannot_cross_boundaries(): Boolean = 
  UML!Message.allInstances()->forAll(m |
    m.sendEvent->oclAsSet()->notEmpty() and m.receiveEvent->oclAsSet()->notEmpty() implies let sendEnclosingFrag : Set(UML!InteractionFragment) = 
      m.sendEvent->oclAsSet()->asOrderedSet()->first().enclosingFragment() in 
        let receiveEnclosingFrag : Set(UML!InteractionFragment) = 
          m.receiveEvent->oclAsSet()->asOrderedSet()->first().enclosingFragment() in 
            sendEnclosingFrag = receiveEnclosingFrag
); 

helper context UML!Message def: signature_is_signal(): Boolean = 
  UML!Message.allInstances()->forAll(m |
    m.messageSort = MessageSort.asynchSignal and m.signature.oclIsKindOf(UML!Signal) implies let signalAttributes : OrderedSet(UML!Property) = 
      m.signature.oclAsType(UML!Signal).inheritedMember()->select(n| 
        n.oclIsTypeOf(UML!Property))->collect(ne| 
        ne.oclAsType(UML!Property))->asOrderedSet() in 
        signalAttributes->size() = m.argument->size() and m.argument->forAll(o| 
          not(o.oclIsKindOf(UML!Expression) and o.oclAsType(UML!Expression).symbol->oclAsSet()->size() = 0 and o.oclAsType(UML!Expression).operand->isEmpty()) implies let p : UML!Property = 
            signalAttributes->at(m.argument.indexOf(o)) in 
              o.type.oclAsType(UML!Classifier).conformsTo(p.type.oclAsType(UML!Classifier)))
); 

helper context UML!Message def: occurrence_specifications(): Boolean = 
  UML!Message.allInstances()->forAll(m |
    OclUndefined
); 

helper context UML!Message def: signature_refer_to(): Boolean = 
  UML!Message.allInstances()->forAll(m |
    m.signature->oclAsSet()->notEmpty() implies m.signature.oclIsKindOf(UML!Operation) and m.messageSort = MessageSort.asynchCall or m.messageSort = MessageSort.synchCall or m.messageSort = MessageSort.reply or m.signature.oclIsKindOf(UML!Signal) and m.messageSort = MessageSort.asynchSignal and m.name = m.signature.name
); 

helper context UML!Message def: signature_is_operation_request(): Boolean = 
  UML!Message.allInstances()->forAll(m |
    m.messageSort = MessageSort.asynchCall or m.messageSort = MessageSort.synchCall and m.signature.oclIsKindOf(UML!Operation) implies let requestParms : OrderedSet(UML!Parameter) = 
      m.signature.oclAsType(UML!Operation).ownedParameter->select(p| 
        p.direction = ParameterDirectionKind.inout or p.direction = ParameterDirectionKind.in) in 
        requestParms->size() = m.argument->size() and m.argument->forAll(o| 
          not(o.oclIsKindOf(UML!Expression) and o.oclAsType(UML!Expression).symbol->oclAsSet()->size() = 0 and o.oclAsType(UML!Expression).operand->isEmpty()) implies let p : UML!Parameter = 
            requestParms->at(m.argument.indexOf(o)) in 
              o.type.oclAsType(UML!Classifier).conformsTo(p.type.oclAsType(UML!Classifier)))
); 

helper context UML!Message def: signature_is_operation_reply(): Boolean = 
  UML!Message.allInstances()->forAll(m |
    m.messageSort = MessageSort.reply and m.signature.oclIsKindOf(UML!Operation) implies let replyParms : OrderedSet(UML!Parameter) = 
      m.signature.oclAsType(UML!Operation).ownedParameter->select(p| 
        p.direction = ParameterDirectionKind.inout or p.direction = ParameterDirectionKind.out or p.direction = ParameterDirectionKind.return) in 
        replyParms->size() = m.argument->size() and m.argument->forAll(o| 
          o.oclIsKindOf(UML!Expression) and let e : UML!Expression = 
            o.oclAsType(UML!Expression) in 
              e.operand->notEmpty() implies let p : UML!Parameter = 
                replyParms->at(m.argument.indexOf(o)) in 
                  e.operand->asSequence()->first().type.oclAsType(UML!Classifier).conformsTo(p.type.oclAsType(UML!Classifier)))
); 

helper context UML!MultiplicityElement def: upper_ge_lower(): Boolean = 
  UML!MultiplicityElement.allInstances()->forAll(me |
    me.upperBound() >= me.lowerBound()
); 

helper context UML!MultiplicityElement def: lower_ge_0(): Boolean = 
  UML!MultiplicityElement.allInstances()->forAll(me |
    me.lowerBound() >= 0
); 

helper context UML!MultiplicityElement def: value_specification_no_side_effects(): Boolean = 
  UML!MultiplicityElement.allInstances()->forAll(me |
    OclUndefined
); 

helper context UML!MultiplicityElement def: value_specification_constant(): Boolean = 
  UML!MultiplicityElement.allInstances()->forAll(me |
    OclUndefined
); 

helper context UML!MultiplicityElement def: lower_is_integer(): Boolean = 
  UML!MultiplicityElement.allInstances()->forAll(me |
    me.lowerValue <> OclUndefined implies me.lowerValue.integerValue() <> OclUndefined
); 

helper context UML!MultiplicityElement def: upper_is_unlimitedNatural(): Boolean = 
  UML!MultiplicityElement.allInstances()->forAll(me |
    me.upperValue <> OclUndefined implies me.upperValue.unlimitedValue() <> OclUndefined
); 

helper context UML!NamedElement def: visibility_needs_ownership(): Boolean = 
  UML!NamedElement.allInstances()->forAll(ne |
    ne.namespace = OclUndefined and ne.owner <> OclUndefined implies ne.visibility = OclUndefined
); 

helper context UML!NamedElement def: has_qualified_name(): Boolean = 
  UML!NamedElement.allInstances()->forAll(ne |
    ne.name <> OclUndefined and ne.allNamespaces()->select(ns| 
      ns.name = OclUndefined)->isEmpty() implies ne.qualifiedName = // We dont understand ocl expression IterateExp
); 

helper context UML!NamedElement def: has_no_qualified_name(): Boolean = 
  UML!NamedElement.allInstances()->forAll(ne |
    ne.name = OclUndefined or ne.allNamespaces()->select(ns| 
      ns.name = OclUndefined)->notEmpty() implies ne.qualifiedName = OclUndefined
); 

helper context UML!Namespace def: members_distinguishable(): Boolean = 
  UML!Namespace.allInstances()->forAll(n |
    n.membersAreDistinguishable()
); 

helper context UML!Namespace def: cannot_import_self(): Boolean = 
  UML!Namespace.allInstances()->forAll(n |
    n.packageImport->collect(pi| 
      pi.importedPackage)->collect(p| 
      p.oclAsType(UML!Namespace))->excludes(n)
); 

helper context UML!Namespace def: cannot_import_ownedMembers(): Boolean = 
  UML!Namespace.allInstances()->forAll(n |
    n.elementImport->collect(ei| 
      ei.importedElement)->collect(pe| 
      pe.oclAsType(UML!Element))->excludesAll(n.ownedMember)
); 

helper context UML!Node def: internal_structure(): Boolean = 
  UML!Node.allInstances()->forAll(n |
    n.part->forAll(p| 
      p.oclIsKindOf(UML!Node))
); 

helper context UML!ObjectFlow def: input_and_output_parameter(): Boolean = 
  UML!ObjectFlow.allInstances()->forAll(of |
    of.selection <> OclUndefined implies of.selection.inputParameters()->size() = 1 and of.selection.inputParameters()->forAll(p| 
      not(p.isUnique) and p->is(0,*)) and of.selection.outputParameters()->size() = 1
); 

helper context UML!ObjectFlow def: no_executable_nodes(): Boolean = 
  UML!ObjectFlow.allInstances()->forAll(of |
    not(of.source.oclIsKindOf(UML!ExecutableNode) or of.target.oclIsKindOf(UML!ExecutableNode))
); 

helper context UML!ObjectFlow def: transformation_behavior(): Boolean = 
  UML!ObjectFlow.allInstances()->forAll(of |
    of.transformation <> OclUndefined implies of.transformation.inputParameters()->size() = 1 and of.transformation.outputParameters()->size() = 1
); 

helper context UML!ObjectFlow def: selection_behavior(): Boolean = 
  UML!ObjectFlow.allInstances()->forAll(of |
    of.selection <> OclUndefined implies of.source.oclIsKindOf(UML!ObjectNode)
); 

helper context UML!ObjectFlow def: compatible_types(): Boolean = 
  UML!ObjectFlow.allInstances()->forAll(of |
    OclUndefined
); 

helper context UML!ObjectFlow def: same_upper_bounds(): Boolean = 
  UML!ObjectFlow.allInstances()->forAll(of |
    OclUndefined
); 

helper context UML!ObjectFlow def: target(): Boolean = 
  UML!ObjectFlow.allInstances()->forAll(of |
    OclUndefined
); 

helper context UML!ObjectFlow def: is_multicast_or_is_multireceive(): Boolean = 
  UML!ObjectFlow.allInstances()->forAll(of |
    not(of.isMulticast and of.isMultireceive)
); 

helper context UML!ObjectNode def: input_output_parameter(): Boolean = 
  UML!ObjectNode.allInstances()->forAll(on |
    on.selection <> OclUndefined implies on.selection.inputParameters()->size() = 1 and on.selection.inputParameters()->forAll(p| 
      not(p.isUnique) and p->is(0,*) and on.type.conformsTo(p.type)) and on.selection.outputParameters()->size() = 1 and on.selection.inputParameters()->forAll(p| 
      on.type.conformsTo(p.type))
); 

helper context UML!ObjectNode def: selection_behavior(): Boolean = 
  UML!ObjectNode.allInstances()->forAll(on |
    on.selection <> OclUndefined = on.ordering = ObjectNodeOrderingKind.ordered
); 

helper context UML!ObjectNode def: object_flow_edges(): Boolean = 
  UML!ObjectNode.allInstances()->forAll(on |
    not(on.isControlType) implies on.incoming.()->forAll(ae| 
      ae.oclIsKindOf(UML!ObjectFlow))
); 

helper context UML!OpaqueAction def: language_body_size(): Boolean = 
  UML!OpaqueAction.allInstances()->forAll(oa |
    oa.language->notEmpty() implies oa.body->size() = oa.language->size()
); 

helper context UML!OpaqueExpression def: language_body_size(): Boolean = 
  UML!OpaqueExpression.allInstances()->forAll(oe |
    oe.language->notEmpty() implies oe.body->size() = oe.language->size()
); 

helper context UML!OpaqueExpression def: one_return_result_parameter(): Boolean = 
  UML!OpaqueExpression.allInstances()->forAll(oe |
    oe.behavior <> OclUndefined implies oe.behavior.ownedParameter->select(p| 
      p.direction = ParameterDirectionKind.return)->size() = 1
); 

helper context UML!OpaqueExpression def: only_return_result_parameters(): Boolean = 
  UML!OpaqueExpression.allInstances()->forAll(oe |
    oe.behavior <> OclUndefined implies oe.behavior.ownedParameter->select(p| 
      p.direction <> ParameterDirectionKind.return)->isEmpty()
); 

helper context UML!Operation def: at_most_one_return(): Boolean = 
  UML!Operation.allInstances()->forAll(o |
    o.ownedParameter->select(p| 
      p.direction = ParameterDirectionKind.return)->size() <= 1
); 

helper context UML!Operation def: only_body_for_query(): Boolean = 
  UML!Operation.allInstances()->forAll(o |
    o.bodyCondition <> OclUndefined implies o.isQuery
); 

helper context UML!OperationTemplateParameter def: match_default_signature(): Boolean = 
  UML!OperationTemplateParameter.allInstances()->forAll(otp |
    otp.default->oclAsSet()->notEmpty() implies otp.default.oclIsKindOf(UML!Operation) and let defaultOp : UML!Operation = 
      otp.default.oclAsType(UML!Operation) in 
        defaultOp.ownedParameter->size() = otp.parameteredElement.ownedParameter->size() and Sequence{}->forAll(ix| 
          let p1 : UML!Parameter = 
            defaultOp.ownedParameter->at(ix) in 
              let p2 : UML!Parameter = 
                otp.parameteredElement.ownedParameter->at(ix) in 
                  p1.type = p2.type and p1.upper = p2.upper and p1.lower = p2.lower and p1.direction = p2.direction and p1.isOrdered = p2.isOrdered and p1.isUnique = p2.isUnique)
); 

helper context UML!OutputPin def: incoming_edges_structured_only(): Boolean = 
  UML!OutputPin.allInstances()->forAll(op |
    op.incoming->notEmpty() implies op.output <> OclUndefined and op.output.oclIsKindOf(UML!StructuredActivityNode) and op.output.oclAsType(UML!StructuredActivityNode).allOwnedNodes()->includesAll(op.incoming->collect(ae| 
      ae.source))
); 

helper context UML!Package def: elements_public_or_private(): Boolean = 
  UML!Package.allInstances()->forAll(p |
    p.packagedElement->forAll(e| 
      e.visibility <> OclUndefined implies e.visibility = VisibilityKind.public or e.visibility = VisibilityKind.private)
); 

helper context UML!PackageImport def: public_or_private(): Boolean = 
  UML!PackageImport.allInstances()->forAll(pi |
    pi.visibility = VisibilityKind.public or pi.visibility = VisibilityKind.private
); 

helper context UML!PackageableElement def: namespace_needs_visibility(): Boolean = 
  UML!PackageableElement.allInstances()->forAll(pe |
    pe.visibility = OclUndefined implies pe.namespace = OclUndefined
); 

helper context UML!Parameter def: in_and_out(): Boolean = 
  UML!Parameter.allInstances()->forAll(p |
    p.effect = ParameterEffectKind.delete implies p.direction = ParameterDirectionKind.in or p.direction = ParameterDirectionKind.inout and p.effect = ParameterEffectKind.create implies p.direction = ParameterDirectionKind.out or p.direction = ParameterDirectionKind.inout or p.direction = ParameterDirectionKind.return
); 

helper context UML!Parameter def: not_exception(): Boolean = 
  UML!Parameter.allInstances()->forAll(p |
    p.isException implies p.direction <> ParameterDirectionKind.in and p.direction <> ParameterDirectionKind.inout
); 

helper context UML!Parameter def: connector_end(): Boolean = 
  UML!Parameter.allInstances()->forAll(p |
    p.end->notEmpty() implies p.collaborationRole->notEmpty()
); 

helper context UML!Parameter def: reentrant_behaviors(): Boolean = 
  UML!Parameter.allInstances()->forAll(p |
    p.isStream and p.ownedParameter <> OclUndefined implies not(p.ownedParameter.isReentrant)
); 

helper context UML!Parameter def: stream_and_exception(): Boolean = 
  UML!Parameter.allInstances()->forAll(p |
    not(p.isException and p.isStream)
); 

helper context UML!Parameter def: object_effect(): Boolean = 
  UML!Parameter.allInstances()->forAll(p |
    p.type.oclIsKindOf(UML!DataType) implies p.effect = OclUndefined
); 

helper context UML!ParameterSet def: same_parameterized_entity(): Boolean = 
  UML!ParameterSet.allInstances()->forAll(ps |
    ps.parameter->forAll(p1,p2| 
      ps.owner = p1.owner and ps.owner = p2.owner and p1.direction = p2.direction)
); 

helper context UML!ParameterSet def: input(): Boolean = 
  UML!ParameterSet.allInstances()->forAll(ps |
    ps.parameter->exists(p| 
      p.direction = ParameterDirectionKind.in) implies ps.ownedParameterSet.ownedParameter->select(p| 
      p.direction = ParameterDirectionKind.in and p.parameterSet->isEmpty())->forAll(p| 
      p.isStream) and ps.parameter->exists(p| 
      p.direction = ParameterDirectionKind.out) implies ps.ownedParameterSet.ownedParameter->select(p| 
      p.direction = ParameterDirectionKind.out and p.parameterSet->isEmpty())->forAll(p| 
      p.isStream)
); 

helper context UML!ParameterSet def: two_parameter_sets(): Boolean = 
  UML!ParameterSet.allInstances()->forAll(ps |
    ps.parameter->forAll(p| 
      p.parameterSet->forAll(s1,s2| 
        s1->oclAsSet()->size() = s2->oclAsSet()->size() implies s1.parameter->exists(p| 
          not(s2.parameter->includes(p)))))
); 

helper context UML!Pin def: control_pins(): Boolean = 
  UML!Pin.allInstances()->forAll(p |
    p.isControl implies p.isControlType
); 

helper context UML!Pin def: not_unique(): Boolean = 
  UML!Pin.allInstances()->forAll(p |
    not(p.isUnique)
); 

helper context UML!Port def: port_aggregation(): Boolean = 
  UML!Port.allInstances()->forAll(p |
    p.aggregation = AggregationKind.composite
); 

helper context UML!Port def: default_value(): Boolean = 
  UML!Port.allInstances()->forAll(p |
    p.type.oclIsKindOf(UML!Interface) implies p.defaultValue->oclAsSet()->isEmpty()
); 

helper context UML!Port def: encapsulated_owner(): Boolean = 
  UML!Port.allInstances()->forAll(p |
    p.owner = p.ownedPort
); 

helper context UML!Profile def: metaclass_reference_not_specialized(): Boolean = 
  UML!Profile.allInstances()->forAll(p |
    p.metaclassReference->collect(ei| 
      ei.importedElement)->select(c| 
      c.oclIsKindOf(UML!Classifier) and c.oclAsType(UML!Classifier).allParents()->collect(c| 
        c.namespace)->includes(p))->isEmpty() and p.packagedElement->select(pe| 
      pe.oclIsKindOf(UML!Classifier))->collect(pe| 
      pe.oclAsType(UML!Classifier).allParents()).()->isEmpty()
); 

helper context UML!Profile def: references_same_metamodel(): Boolean = 
  UML!Profile.allInstances()->forAll(p |
    p.metamodelReference->collect(pi| 
      pi.importedPackage)->collect(p| 
      p.elementImport)->collect(ei| 
      ei.importedElement)->collect(pe| 
      pe.allOwningPackages()).()->notEmpty()
); 

helper context UML!Property def: subsetting_context_conforms(): Boolean = 
  UML!Property.allInstances()->forAll(p |
    p.subsettedProperty->notEmpty() implies p.subsettingContext()->notEmpty() and p.subsettingContext()->forAll(sc| 
      p.subsettedProperty->forAll(sp| 
        sp.subsettingContext()->exists(c| 
          sc.conformsTo(c))))
); 

helper context UML!Property def: derived_union_is_read_only(): Boolean = 
  UML!Property.allInstances()->forAll(p |
    p.isDerivedUnion implies p.isReadOnly
); 

helper context UML!Property def: multiplicity_of_composite(): Boolean = 
  UML!Property.allInstances()->forAll(p |
    p.isComposite and p.association <> OclUndefined implies p.opposite.upperBound() <= 1
); 

helper context UML!Property def: redefined_property_inherited(): Boolean = 
  UML!Property.allInstances()->forAll(p |
    p.redefinedProperty->notEmpty() implies p.redefinitionContext->notEmpty() and p.redefinedProperty->forAll(rp| 
      p.redefinitionContext->collect(fc| 
        fc.allParents())->asSet()->collect(c| 
        c.allFeatures())->asSet()->includes(rp))
); 

helper context UML!Property def: subsetting_rules(): Boolean = 
  UML!Property.allInstances()->forAll(p |
    p.subsettedProperty->forAll(sp| 
      p.type.conformsTo(sp.type) and p.upperBound()->oclAsSet()->notEmpty() and sp.upperBound()->oclAsSet()->notEmpty() implies p.upperBound() <= sp.upperBound())
); 

helper context UML!Property def: binding_to_attribute(): Boolean = 
  UML!Property.allInstances()->forAll(p |
    p.isAttribute() and p.actual->notEmpty() implies p.actual->forAll(ts| 
      ts.formal.oclIsKindOf(UML!Property) and ts.formal.oclAsType(UML!Property).isAttribute())
); 

helper context UML!Property def: derived_union_is_derived(): Boolean = 
  UML!Property.allInstances()->forAll(p |
    p.isDerivedUnion implies p.isDerived
); 

helper context UML!Property def: deployment_target(): Boolean = 
  UML!Property.allInstances()->forAll(p |
    p.deployment->notEmpty() implies p.owner.oclIsKindOf(UML!Node) and UML!Node->allInstances()->exists(n| 
      n.part->exists(p| 
        p = p))
); 

helper context UML!Property def: subsetted_property_names(): Boolean = 
  UML!Property.allInstances()->forAll(p |
    p.subsettedProperty->forAll(sp| 
      sp.name <> p.name)
); 

helper context UML!Property def: type_of_opposite_end(): Boolean = 
  UML!Property.allInstances()->forAll(p |
    p.opposite->oclAsSet()->notEmpty() and p.owningAssociation->oclAsSet()->isEmpty() implies p.attribute = p.opposite.type
); 

helper context UML!Property def: qualified_is_association_end(): Boolean = 
  UML!Property.allInstances()->forAll(p |
    p.qualifier->notEmpty() implies p.association->oclAsSet()->notEmpty()
); 

helper context UML!ProtocolStateMachine def: classifier_context(): Boolean = 
  UML!ProtocolStateMachine.allInstances()->forAll(psm |
    psm.context <> OclUndefined and psm.specification = OclUndefined
); 

helper context UML!ProtocolStateMachine def: deep_or_shallow_history(): Boolean = 
  UML!ProtocolStateMachine.allInstances()->forAll(psm |
    psm.region->forAll(r| 
      r.subvertex->forAll(v| 
        v.oclIsKindOf(UML!Pseudostate) implies v.oclAsType(UML!Pseudostate).kind <> PseudostateKind.deepHistory and v.oclAsType(UML!Pseudostate).kind <> PseudostateKind.shallowHistory))
); 

helper context UML!ProtocolStateMachine def: entry_exit_do(): Boolean = 
  UML!ProtocolStateMachine.allInstances()->forAll(psm |
    psm.region->forAll(r| 
      r.subvertex->forAll(v| 
        v.oclIsKindOf(UML!State) implies v.oclAsType(UML!State).entry->oclAsSet()->isEmpty() and v.oclAsType(UML!State).exit->oclAsSet()->isEmpty() and v.oclAsType(UML!State).doActivity->oclAsSet()->isEmpty()))
); 

helper context UML!ProtocolStateMachine def: protocol_transitions(): Boolean = 
  UML!ProtocolStateMachine.allInstances()->forAll(psm |
    psm.region->forAll(r| 
      r.transition->forAll(t| 
        t.oclIsTypeOf(UML!ProtocolTransition)))
); 

helper context UML!ProtocolTransition def: refers_to_operation(): Boolean = 
  UML!ProtocolTransition.allInstances()->forAll(pt |
    if (pt.referred()->notEmpty() and pt.containingStateMachine().context->oclAsSet()->notEmpty()) then 
      pt.containingStateMachine().context.oclAsType(UML!BehavioredClassifier).allFeatures()->includesAll(pt.referred())
    else 
      true
    endif
); 

helper context UML!ProtocolTransition def: associated_actions(): Boolean = 
  UML!ProtocolTransition.allInstances()->forAll(pt |
    pt.effect = OclUndefined
); 

helper context UML!ProtocolTransition def: belongs_to_psm(): Boolean = 
  UML!ProtocolTransition.allInstances()->forAll(pt |
    pt.container.belongsToPSM()
); 

helper context UML!Pseudostate def: transitions_outgoing(): Boolean = 
  UML!Pseudostate.allInstances()->forAll(p |
    p.kind = PseudostateKind.fork implies p.outgoing->forAll(t1,t2| 
      let contState : UML!State = 
        p.containingStateMachine().LCAState(t1.target,t2.target) in 
          contState <> OclUndefined and contState.region->exists(r1,r2| 
            r1 <> r2 and t1.target.isContainedInRegion(r1) and t2.target.isContainedInRegion(r2)))
); 

helper context UML!Pseudostate def: choice_vertex(): Boolean = 
  UML!Pseudostate.allInstances()->forAll(p |
    p.kind = PseudostateKind.choice implies p.incoming->size() >= 1 and p.outgoing->size() >= 1
); 

helper context UML!Pseudostate def: outgoing_from_initial(): Boolean = 
  UML!Pseudostate.allInstances()->forAll(p |
    p.kind = PseudostateKind.initial implies p.outgoing->collect(t| 
      t.guard) = OclUndefined and p.outgoing->collect(t| 
      t.trigger)->isEmpty()
); 

helper context UML!Pseudostate def: join_vertex(): Boolean = 
  UML!Pseudostate.allInstances()->forAll(p |
    p.kind = PseudostateKind.join implies p.outgoing->size() = 1 and p.incoming->size() >= 2
); 

helper context UML!Pseudostate def: junction_vertex(): Boolean = 
  UML!Pseudostate.allInstances()->forAll(p |
    p.kind = PseudostateKind.junction implies p.incoming->size() >= 1 and p.outgoing->size() >= 1
); 

helper context UML!Pseudostate def: history_vertices(): Boolean = 
  UML!Pseudostate.allInstances()->forAll(p |
    p.kind = PseudostateKind.deepHistory or p.kind = PseudostateKind.shallowHistory implies p.outgoing->size() <= 1
); 

helper context UML!Pseudostate def: initial_vertex(): Boolean = 
  UML!Pseudostate.allInstances()->forAll(p |
    p.kind = PseudostateKind.initial implies p.outgoing->size() <= 1
); 

helper context UML!Pseudostate def: fork_vertex(): Boolean = 
  UML!Pseudostate.allInstances()->forAll(p |
    p.kind = PseudostateKind.fork implies p.incoming->size() = 1 and p.outgoing->size() >= 2
); 

helper context UML!Pseudostate def: transitions_incoming(): Boolean = 
  UML!Pseudostate.allInstances()->forAll(p |
    p.kind = PseudostateKind.join implies p.incoming->forAll(t1,t2| 
      let contState : UML!State = 
        p.containingStateMachine().LCAState(t1.source,t2.source) in 
          contState <> OclUndefined and contState.region->exists(r1,r2| 
            r1 <> r2 and t1.source.isContainedInRegion(r1) and t2.source.isContainedInRegion(r2)))
); 

helper context UML!QualifierValue def: multiplicity_of_qualifier(): Boolean = 
  UML!QualifierValue.allInstances()->forAll(qv |
    qv.value->is(1,1.toUnlimitedNatural())
); 

helper context UML!QualifierValue def: type_of_qualifier(): Boolean = 
  UML!QualifierValue.allInstances()->forAll(qv |
    qv.value.type.conformsTo(qv.qualifier.type)
); 

helper context UML!QualifierValue def: qualifier_attribute(): Boolean = 
  UML!QualifierValue.allInstances()->forAll(qv |
    qv.qualifier.end.qualifier->includes(qv.qualifier)
); 

helper context UML!ReadExtentAction def: type_is_classifier(): Boolean = 
  UML!ReadExtentAction.allInstances()->forAll(rea |
    rea.result.type = rea.classifier
); 

helper context UML!ReadExtentAction def: multiplicity_of_result(): Boolean = 
  UML!ReadExtentAction.allInstances()->forAll(rea |
    rea.result->is(0,*)
); 

helper context UML!ReadIsClassifiedObjectAction def: no_type(): Boolean = 
  UML!ReadIsClassifiedObjectAction.allInstances()->forAll(ricoa |
    ricoa.object.type = OclUndefined
); 

helper context UML!ReadIsClassifiedObjectAction def: multiplicity_of_output(): Boolean = 
  UML!ReadIsClassifiedObjectAction.allInstances()->forAll(ricoa |
    ricoa.result->is(1,1.toUnlimitedNatural())
); 

helper context UML!ReadIsClassifiedObjectAction def: boolean_result(): Boolean = 
  UML!ReadIsClassifiedObjectAction.allInstances()->forAll(ricoa |
    ricoa.result.type = Boolean
); 

helper context UML!ReadIsClassifiedObjectAction def: multiplicity_of_input(): Boolean = 
  UML!ReadIsClassifiedObjectAction.allInstances()->forAll(ricoa |
    ricoa.object->is(1,1.toUnlimitedNatural())
); 

helper context UML!ReadLinkAction def: type_and_ordering(): Boolean = 
  UML!ReadLinkAction.allInstances()->forAll(rla |
    rla.openEnd()->forAll(p| 
      p.type = rla.result.type and p.isOrdered = rla.result.isOrdered)
); 

helper context UML!ReadLinkAction def: compatible_multiplicity(): Boolean = 
  UML!ReadLinkAction.allInstances()->forAll(rla |
    rla.openEnd()->first().compatibleWith(rla.result)
); 

helper context UML!ReadLinkAction def: visibility(): Boolean = 
  UML!ReadLinkAction.allInstances()->forAll(rla |
    let openEnd : UML!Property = 
      rla.openEnd()->first() in 
        openEnd.visibility = VisibilityKind.public or rla.endData->exists(oed| 
          oed.end <> openEnd and rla.context = oed.end.type or openEnd.visibility = VisibilityKind.protected and rla.context.conformsTo(oed.end.type.oclAsType(UML!Classifier)))
); 

helper context UML!ReadLinkAction def: one_open_end(): Boolean = 
  UML!ReadLinkAction.allInstances()->forAll(rla |
    rla.openEnd()->size() = 1
); 

helper context UML!ReadLinkAction def: navigable_open_end(): Boolean = 
  UML!ReadLinkAction.allInstances()->forAll(rla |
    rla.openEnd()->first().isNavigable()
); 

helper context UML!ReadLinkObjectEndAction def: property(): Boolean = 
  UML!ReadLinkObjectEndAction.allInstances()->forAll(rloea |
    rloea.end.association <> OclUndefined
); 

helper context UML!ReadLinkObjectEndAction def: multiplicity_of_object(): Boolean = 
  UML!ReadLinkObjectEndAction.allInstances()->forAll(rloea |
    rloea.object->is(1,1.toUnlimitedNatural())
); 

helper context UML!ReadLinkObjectEndAction def: ends_of_association(): Boolean = 
  UML!ReadLinkObjectEndAction.allInstances()->forAll(rloea |
    rloea.end.association.memberEnd->forAll(e| 
      not(e.isStatic))
); 

helper context UML!ReadLinkObjectEndAction def: type_of_result(): Boolean = 
  UML!ReadLinkObjectEndAction.allInstances()->forAll(rloea |
    rloea.result.type = rloea.end.type
); 

helper context UML!ReadLinkObjectEndAction def: multiplicity_of_result(): Boolean = 
  UML!ReadLinkObjectEndAction.allInstances()->forAll(rloea |
    rloea.result->is(1,1.toUnlimitedNatural())
); 

helper context UML!ReadLinkObjectEndAction def: type_of_object(): Boolean = 
  UML!ReadLinkObjectEndAction.allInstances()->forAll(rloea |
    rloea.object.type = rloea.end.association
); 

helper context UML!ReadLinkObjectEndAction def: association_of_association(): Boolean = 
  UML!ReadLinkObjectEndAction.allInstances()->forAll(rloea |
    rloea.end.association.oclIsKindOf(UML!AssociationClass)
); 

helper context UML!ReadLinkObjectEndQualifierAction def: multiplicity_of_object(): Boolean = 
  UML!ReadLinkObjectEndQualifierAction.allInstances()->forAll(rloeqa |
    rloeqa.object->is(1,1.toUnlimitedNatural())
); 

helper context UML!ReadLinkObjectEndQualifierAction def: type_of_object(): Boolean = 
  UML!ReadLinkObjectEndQualifierAction.allInstances()->forAll(rloeqa |
    rloeqa.object.type = rloeqa.qualifier.associationEnd.association
); 

helper context UML!ReadLinkObjectEndQualifierAction def: multiplicity_of_qualifier(): Boolean = 
  UML!ReadLinkObjectEndQualifierAction.allInstances()->forAll(rloeqa |
    rloeqa.qualifier->is(1,1.toUnlimitedNatural())
); 

helper context UML!ReadLinkObjectEndQualifierAction def: ends_of_association(): Boolean = 
  UML!ReadLinkObjectEndQualifierAction.allInstances()->forAll(rloeqa |
    rloeqa.qualifier.associationEnd.association.memberEnd->forAll(e| 
      not(e.isStatic))
); 

helper context UML!ReadLinkObjectEndQualifierAction def: multiplicity_of_result(): Boolean = 
  UML!ReadLinkObjectEndQualifierAction.allInstances()->forAll(rloeqa |
    rloeqa.result->is(1,1.toUnlimitedNatural())
); 

helper context UML!ReadLinkObjectEndQualifierAction def: same_type(): Boolean = 
  UML!ReadLinkObjectEndQualifierAction.allInstances()->forAll(rloeqa |
    rloeqa.result.type = rloeqa.qualifier.type
); 

helper context UML!ReadLinkObjectEndQualifierAction def: association_of_association(): Boolean = 
  UML!ReadLinkObjectEndQualifierAction.allInstances()->forAll(rloeqa |
    rloeqa.qualifier.associationEnd.association.oclIsKindOf(UML!AssociationClass)
); 

helper context UML!ReadLinkObjectEndQualifierAction def: qualifier_attribute(): Boolean = 
  UML!ReadLinkObjectEndQualifierAction.allInstances()->forAll(rloeqa |
    rloeqa.qualifier.associationEnd <> OclUndefined
); 

helper context UML!ReadSelfAction def: contained(): Boolean = 
  UML!ReadSelfAction.allInstances()->forAll(rsa |
    rsa.context <> OclUndefined
); 

helper context UML!ReadSelfAction def: multiplicity(): Boolean = 
  UML!ReadSelfAction.allInstances()->forAll(rsa |
    rsa.result->is(1,1.toUnlimitedNatural())
); 

helper context UML!ReadSelfAction def: not_static(): Boolean = 
  UML!ReadSelfAction.allInstances()->forAll(rsa |
    let behavior : UML!Behavior = 
      rsa.containingBehavior() in 
        behavior.specification <> OclUndefined implies not(behavior.specification.isStatic)
); 

helper context UML!ReadSelfAction def: type(): Boolean = 
  UML!ReadSelfAction.allInstances()->forAll(rsa |
    rsa.result.type = rsa.context
); 

helper context UML!ReadStructuralFeatureAction def: multiplicity(): Boolean = 
  UML!ReadStructuralFeatureAction.allInstances()->forAll(rsfa |
    rsfa.structuralFeature.compatibleWith(rsfa.result)
); 

helper context UML!ReadStructuralFeatureAction def: type_and_ordering(): Boolean = 
  UML!ReadStructuralFeatureAction.allInstances()->forAll(rsfa |
    rsfa.result.type = rsfa.structuralFeature.type and rsfa.result.isOrdered = rsfa.structuralFeature.isOrdered
); 

helper context UML!ReadVariableAction def: type_and_ordering(): Boolean = 
  UML!ReadVariableAction.allInstances()->forAll(rva |
    rva.result.type = rva.variable.type and rva.result.isOrdered = rva.variable.isOrdered
); 

helper context UML!ReadVariableAction def: compatible_multiplicity(): Boolean = 
  UML!ReadVariableAction.allInstances()->forAll(rva |
    rva.variable.compatibleWith(rva.result)
); 

helper context UML!Reception def: same_name_as_signal(): Boolean = 
  UML!Reception.allInstances()->forAll(r |
    r.name = r.signal.name
); 

helper context UML!Reception def: same_structure_as_signal(): Boolean = 
  UML!Reception.allInstances()->forAll(r |
    r.signal.ownedAttribute->size() = r.ownedParameter->size() and Sequence{}->forAll(i| 
      r.ownedParameter->at(i).direction = ParameterDirectionKind.in and r.ownedParameter->at(i).name = r.signal.ownedAttribute->at(i).name and r.ownedParameter->at(i).type = r.signal.ownedAttribute->at(i).type and r.ownedParameter->at(i).lowerBound() = r.signal.ownedAttribute->at(i).lowerBound() and r.ownedParameter->at(i).upperBound() = r.signal.ownedAttribute->at(i).upperBound())
); 

helper context UML!ReclassifyObjectAction def: input_pin(): Boolean = 
  UML!ReclassifyObjectAction.allInstances()->forAll(roa |
    roa.object.type = OclUndefined
); 

helper context UML!ReclassifyObjectAction def: classifier_not_abstract(): Boolean = 
  UML!ReclassifyObjectAction.allInstances()->forAll(roa |
    not(roa.newClassifier->exists(c| 
      c.isAbstract))
); 

helper context UML!ReclassifyObjectAction def: multiplicity(): Boolean = 
  UML!ReclassifyObjectAction.allInstances()->forAll(roa |
    roa.object->is(1,1.toUnlimitedNatural())
); 

helper context UML!RedefinableElement def: redefinition_consistent(): Boolean = 
  UML!RedefinableElement.allInstances()->forAll(re |
    re.redefinedElement->forAll(re| 
      re.isConsistentWith(re))
); 

helper context UML!RedefinableElement def: non_leaf_redefinition(): Boolean = 
  UML!RedefinableElement.allInstances()->forAll(re |
    re.redefinedElement->forAll(re| 
      not(re.isLeaf))
); 

helper context UML!RedefinableElement def: redefinition_context_valid(): Boolean = 
  UML!RedefinableElement.allInstances()->forAll(re |
    re.redefinedElement->forAll(re| 
      re.isRedefinitionContextValid(re))
); 

helper context UML!RedefinableTemplateSignature def: redefines_parents(): Boolean = 
  UML!RedefinableTemplateSignature.allInstances()->forAll(rts |
    rts.classifier.allParents()->forAll(c| 
      c.ownedTemplateSignature->oclAsSet()->notEmpty() implies rts->oclAsSet()->closure(rts| 
        rts.extendedSignature)->includes(c.ownedTemplateSignature))
); 

helper context UML!ReduceAction def: reducer_inputs_output(): Boolean = 
  UML!ReduceAction.allInstances()->forAll(ra |
    let inputs : OrderedSet(UML!Parameter) = 
      ra.reducer.inputParameters() in 
        let outputs : OrderedSet(UML!Parameter) = 
          ra.reducer.outputParameters() in 
            inputs->size() = 2 and outputs->size() = 1 and inputs->collect(p| 
              p.type)->forAll(t| 
              outputs->collect(p| 
                p.type)->forAll(t| 
                t.conformsTo(t)) and ra.collection.upperBound() > 1 implies ra.collection.type.conformsTo(t))
); 

helper context UML!ReduceAction def: input_type_is_collection(): Boolean = 
  UML!ReduceAction.allInstances()->forAll(ra |
    OclUndefined
); 

helper context UML!ReduceAction def: output_types_are_compatible(): Boolean = 
  UML!ReduceAction.allInstances()->forAll(ra |
    ra.reducer.outputParameters()->collect(p| 
      p.type)->forAll(t| 
      t.conformsTo(ra.result.type))
); 

helper context UML!Region def: deep_history_vertex(): Boolean = 
  UML!Region.allInstances()->forAll(r |
    r.subvertex->select(v| 
      v.oclIsKindOf(UML!Pseudostate))->collect(v| 
      v.oclAsType(UML!Pseudostate))->select(p| 
      p.kind = PseudostateKind.deepHistory)->size() <= 1
); 

helper context UML!Region def: shallow_history_vertex(): Boolean = 
  UML!Region.allInstances()->forAll(r |
    r.subvertex->select(v| 
      v.oclIsKindOf(UML!Pseudostate))->collect(v| 
      v.oclAsType(UML!Pseudostate))->select(p| 
      p.kind = PseudostateKind.shallowHistory)->size() <= 1
); 

helper context UML!Region def: owned(): Boolean = 
  UML!Region.allInstances()->forAll(r |
    r.stateMachine <> OclUndefined implies r.state = OclUndefined and r.state <> OclUndefined implies r.stateMachine = OclUndefined
); 

helper context UML!Region def: initial_vertex(): Boolean = 
  UML!Region.allInstances()->forAll(r |
    r.subvertex->select(v| 
      v.oclIsKindOf(UML!Pseudostate))->collect(v| 
      v.oclAsType(UML!Pseudostate))->select(p| 
      p.kind = PseudostateKind.initial)->size() <= 1
); 

helper context UML!RemoveStructuralFeatureValueAction def: removeAt_and_value(): Boolean = 
  UML!RemoveStructuralFeatureValueAction.allInstances()->forAll(rsfva |
    if (rsfva.structuralFeature.isOrdered and not(rsfva.structuralFeature.isUnique) and not(rsfva.isRemoveDuplicates)) then 
      rsfva.value = OclUndefined and rsfva.removeAt <> OclUndefined and rsfva.removeAt.type = UnlimitedNatural and rsfva.removeAt->is(1,1.toUnlimitedNatural())
    else 
      rsfva.removeAt = OclUndefined and rsfva.value <> OclUndefined
    endif
); 

helper context UML!RemoveVariableValueAction def: removeAt_and_value(): Boolean = 
  UML!RemoveVariableValueAction.allInstances()->forAll(rvva |
    if (rvva.variable.isOrdered and not(rvva.variable.isUnique) and not(rvva.isRemoveDuplicates)) then 
      rvva.value = OclUndefined and rvva.removeAt <> OclUndefined and rvva.removeAt.type = UnlimitedNatural and rvva.removeAt->is(1,1.toUnlimitedNatural())
    else 
      rvva.removeAt = OclUndefined and rvva.value <> OclUndefined
    endif
); 

helper context UML!ReplyAction def: pins_match_parameter(): Boolean = 
  UML!ReplyAction.allInstances()->forAll(ra |
    let parameter : OrderedSet(UML!Parameter) = 
      ra.replyToCall.event.oclAsType(UML!CallEvent).operation.outputParameters() in 
        ra.replyValue->size() = parameter->size() and Sequence{}->forAll(i| 
          ra.replyValue->at(i).type.conformsTo(parameter->at(i).type) and ra.replyValue->at(i).isOrdered = parameter->at(i).isOrdered and ra.replyValue->at(i).compatibleWith(parameter->at(i)))
); 

helper context UML!ReplyAction def: event_on_reply_to_call_trigger(): Boolean = 
  UML!ReplyAction.allInstances()->forAll(ra |
    ra.replyToCall.event.oclIsKindOf(UML!CallEvent)
); 

helper context UML!SendObjectAction def: type_target_pin(): Boolean = 
  UML!SendObjectAction.allInstances()->forAll(soa |
    soa.onPort <> OclUndefined implies soa.target.type.oclAsType(UML!Classifier).allFeatures()->includes(soa.onPort)
); 

helper context UML!SendSignalAction def: type_ordering_multiplicity(): Boolean = 
  UML!SendSignalAction.allInstances()->forAll(ssa |
    let attribute : OrderedSet(UML!Property) = 
      ssa.signal.allAttributes() in 
        Sequence{}->forAll(i| 
          ssa.argument->at(i).type.conformsTo(attribute->at(i).type) and ssa.argument->at(i).isOrdered = attribute->at(i).isOrdered and ssa.argument->at(i).compatibleWith(attribute->at(i)))
); 

helper context UML!SendSignalAction def: number_order(): Boolean = 
  UML!SendSignalAction.allInstances()->forAll(ssa |
    ssa.argument->size() = ssa.signal.allAttributes()->size()
); 

helper context UML!SendSignalAction def: type_target_pin(): Boolean = 
  UML!SendSignalAction.allInstances()->forAll(ssa |
    not(ssa.onPort->oclAsSet()->isEmpty()) implies ssa.target.type.oclAsType(UML!Classifier).allFeatures()->includes(ssa.onPort)
); 

helper context UML!StartClassifierBehaviorAction def: multiplicity(): Boolean = 
  UML!StartClassifierBehaviorAction.allInstances()->forAll(scba |
    scba.object->is(1,1.toUnlimitedNatural())
); 

helper context UML!StartClassifierBehaviorAction def: type_has_classifier(): Boolean = 
  UML!StartClassifierBehaviorAction.allInstances()->forAll(scba |
    scba.object.type->oclAsSet()->notEmpty() implies scba.object.type.oclIsKindOf(UML!BehavioredClassifier) and scba.object.type.oclAsType(UML!BehavioredClassifier).classifierBehavior <> OclUndefined
); 

helper context UML!StartObjectBehaviorAction def: multiplicity_of_object(): Boolean = 
  UML!StartObjectBehaviorAction.allInstances()->forAll(soba |
    soba.object->is(1,1.toUnlimitedNatural())
); 

helper context UML!StartObjectBehaviorAction def: type_of_object(): Boolean = 
  UML!StartObjectBehaviorAction.allInstances()->forAll(soba |
    soba.behavior() <> OclUndefined
); 

helper context UML!StartObjectBehaviorAction def: no_onport(): Boolean = 
  UML!StartObjectBehaviorAction.allInstances()->forAll(soba |
    soba.onPort->oclAsSet()->isEmpty()
); 

helper context UML!State def: entry_or_exit(): Boolean = 
  UML!State.allInstances()->forAll(s |
    s.connectionPoint->forAll(p| 
      p.kind = PseudostateKind.entryPoint or p.kind = PseudostateKind.exitPoint)
); 

helper context UML!State def: submachine_states(): Boolean = 
  UML!State.allInstances()->forAll(s |
    s.isSubmachineState implies s.connection->notEmpty()
); 

helper context UML!State def: composite_states(): Boolean = 
  UML!State.allInstances()->forAll(s |
    s.connectionPoint->notEmpty() implies s.isComposite
); 

helper context UML!State def: destinations_or_sources_of_transitions(): Boolean = 
  UML!State.allInstances()->forAll(s |
    s.isSubmachineState implies s.connection->forAll(cp| 
      cp.entry->forAll(ps| 
        ps.stateMachine = s.submachine) and cp.exit->forAll(ps| 
        ps.stateMachine = s.submachine))
); 

helper context UML!State def: submachine_or_regions(): Boolean = 
  UML!State.allInstances()->forAll(s |
    s.isComposite implies not(s.isSubmachineState)
); 

helper context UML!StateMachine def: connection_points(): Boolean = 
  UML!StateMachine.allInstances()->forAll(sm |
    sm.connectionPoint->forAll(p| 
      p.kind = PseudostateKind.entryPoint or p.kind = PseudostateKind.exitPoint)
); 

helper context UML!StateMachine def: classifier_context(): Boolean = 
  UML!StateMachine.allInstances()->forAll(sm |
    sm.context <> OclUndefined implies not(sm.context.oclIsKindOf(UML!Interface))
); 

helper context UML!StateMachine def: method(): Boolean = 
  UML!StateMachine.allInstances()->forAll(sm |
    sm.specification <> OclUndefined implies sm.connectionPoint->isEmpty()
); 

helper context UML!StateMachine def: context_classifier(): Boolean = 
  UML!StateMachine.allInstances()->forAll(sm |
    sm.specification <> OclUndefined implies sm.context <> OclUndefined and sm.specification.featuringClassifier->oclAsSet()->exists(c| 
      c = sm.context)
); 

helper context UML!Stereotype def: binaryAssociationsOnly(): Boolean = 
  UML!Stereotype.allInstances()->forAll(s |
    s.ownedAttribute->collect(p| 
      p.association)->forAll(a| 
      a.memberEnd->size() = 2)
); 

helper context UML!Stereotype def: generalize(): Boolean = 
  UML!Stereotype.allInstances()->forAll(s |
    s.allParents()->forAll(c| 
      c.oclIsKindOf(UML!Stereotype)) and UML!Classifier->allInstances()->forAll(c| 
      c.allParents()->exists(c| 
        c.oclIsKindOf(UML!Stereotype)) implies c.oclIsKindOf(UML!Stereotype))
); 

helper context UML!Stereotype def: name_not_clash(): Boolean = 
  UML!Stereotype.allInstances()->forAll(s |
    OclUndefined
); 

helper context UML!Stereotype def: associationEndOwnership(): Boolean = 
  UML!Stereotype.allInstances()->forAll(s |
    s.ownedAttribute->select(p| 
      p.association->oclAsSet()->notEmpty() and not(p.association.oclIsKindOf(UML!Extension)) and not(p.type.oclIsKindOf(UML!Stereotype)))->forAll(p| 
      p.opposite.owner = p.association)
); 

helper context UML!Stereotype def: base_property_upper_bound(): Boolean = 
  UML!Stereotype.allInstances()->forAll(s |
    OclUndefined
); 

helper context UML!Stereotype def: base_property_multiplicity_single_extension(): Boolean = 
  UML!Stereotype.allInstances()->forAll(s |
    OclUndefined
); 

helper context UML!Stereotype def: base_property_multiplicity_multiple_extension(): Boolean = 
  UML!Stereotype.allInstances()->forAll(s |
    OclUndefined
); 

helper context UML!StringExpression def: operands(): Boolean = 
  UML!StringExpression.allInstances()->forAll(se |
    se.operand->forAll(vs| 
      vs.oclIsKindOf(UML!LiteralString))
); 

helper context UML!StringExpression def: subexpressions(): Boolean = 
  UML!StringExpression.allInstances()->forAll(se |
    if (se.subExpression->notEmpty()) then 
      se.operand->isEmpty()
    else 
      se.operand->notEmpty()
    endif
); 

helper context UML!StructuralFeatureAction def: multiplicity(): Boolean = 
  UML!StructuralFeatureAction.allInstances()->forAll(sfa |
    sfa.object->is(1,1.toUnlimitedNatural())
); 

helper context UML!StructuralFeatureAction def: object_type(): Boolean = 
  UML!StructuralFeatureAction.allInstances()->forAll(sfa |
    sfa.object.type.oclAsType(UML!Classifier).allFeatures()->includes(sfa.structuralFeature) or sfa.object.type.conformsTo(sfa.structuralFeature.oclAsType(UML!Property).opposite.type)
); 

helper context UML!StructuralFeatureAction def: visibility(): Boolean = 
  UML!StructuralFeatureAction.allInstances()->forAll(sfa |
    sfa.structuralFeature.visibility = VisibilityKind.public or sfa.context.allFeatures()->includes(sfa.structuralFeature) or sfa.structuralFeature.visibility = VisibilityKind.protected and sfa.context.conformsTo(sfa.structuralFeature.oclAsType(UML!Property).opposite.type.oclAsType(UML!Classifier))
); 

helper context UML!StructuralFeatureAction def: not_static(): Boolean = 
  UML!StructuralFeatureAction.allInstances()->forAll(sfa |
    not(sfa.structuralFeature.isStatic)
); 

helper context UML!StructuralFeatureAction def: one_featuring_classifier(): Boolean = 
  UML!StructuralFeatureAction.allInstances()->forAll(sfa |
    sfa.structuralFeature.featuringClassifier->oclAsSet()->size() = 1
); 

helper context UML!StructuredActivityNode def: output_pin_edges(): Boolean = 
  UML!StructuredActivityNode.allInstances()->forAll(san |
    san.output->collect(op| 
      op.outgoing)->collect(ae| 
      ae.target)->excludesAll(san.allOwnedNodes() - san.input)
); 

helper context UML!StructuredActivityNode def: edges(): Boolean = 
  UML!StructuredActivityNode.allInstances()->forAll(san |
    san.edge = san.sourceNodes()->collect(an| 
      an.outgoing).().()->asSet()
); 

helper context UML!StructuredActivityNode def: input_pin_edges(): Boolean = 
  UML!StructuredActivityNode.allInstances()->forAll(san |
    san.input->collect(ip| 
      ip.incoming)->collect(ae| 
      ae.source)->excludesAll(san.allOwnedNodes() - san.output)
); 

helper context UML!TemplateBinding def: parameter_substitution_formal(): Boolean = 
  UML!TemplateBinding.allInstances()->forAll(tb |
    tb.parameterSubstitution->forAll(b| 
      tb.signature.parameter->includes(b.formal))
); 

helper context UML!TemplateBinding def: one_parameter_substitution(): Boolean = 
  UML!TemplateBinding.allInstances()->forAll(tb |
    tb.signature.parameter->forAll(p| 
      tb.parameterSubstitution->select(b| 
        b.formal = p)->size() <= 1)
); 

helper context UML!TemplateParameter def: must_be_compatible(): Boolean = 
  UML!TemplateParameter.allInstances()->forAll(tp |
    tp.default <> OclUndefined implies tp.default.isCompatibleWith(tp.parameteredElement)
); 

helper context UML!TemplateParameterSubstitution def: must_be_compatible(): Boolean = 
  UML!TemplateParameterSubstitution.allInstances()->forAll(tps |
    tps.actual->oclAsSet()->forAll(a| 
      a.isCompatibleWith(tps.formal.parameteredElement))
); 

helper context UML!TemplateSignature def: own_elements(): Boolean = 
  UML!TemplateSignature.allInstances()->forAll(ts |
    ts.template.ownedElement->includesAll(ts.parameter->collect(tp| 
      tp.parameteredElement)->asSet() - ts.parameter->collect(tp| 
      tp.ownedParameteredElement)->asSet())
); 

helper context UML!TemplateSignature def: unique_parameters(): Boolean = 
  UML!TemplateSignature.allInstances()->forAll(ts |
    ts.parameter->forAll(p1,p2| 
      p1 <> p2 and p1.parameteredElement.oclIsKindOf(UML!NamedElement) and p2.parameteredElement.oclIsKindOf(UML!NamedElement) implies p1.parameteredElement.oclAsType(UML!NamedElement).name <> p2.parameteredElement.oclAsType(UML!NamedElement).name)
); 

helper context UML!TestIdentityAction def: multiplicity(): Boolean = 
  UML!TestIdentityAction.allInstances()->forAll(tia |
    tia.first->is(1,1.toUnlimitedNatural()) and tia.second->is(1,1.toUnlimitedNatural())
); 

helper context UML!TestIdentityAction def: no_type(): Boolean = 
  UML!TestIdentityAction.allInstances()->forAll(tia |
    tia.first.type = OclUndefined and tia.second.type = OclUndefined
); 

helper context UML!TestIdentityAction def: result_is_boolean(): Boolean = 
  UML!TestIdentityAction.allInstances()->forAll(tia |
    tia.result.type = Boolean
); 

helper context UML!TimeConstraint def: has_one_constrainedElement(): Boolean = 
  UML!TimeConstraint.allInstances()->forAll(tc |
    tc.constrainedElement->size() = 1
); 

helper context UML!TimeEvent def: when_non_negative(): Boolean = 
  UML!TimeEvent.allInstances()->forAll(te |
    te.when.integerValue() >= 0
); 

helper context UML!TimeExpression def: no_expr_requires_observation(): Boolean = 
  UML!TimeExpression.allInstances()->forAll(te |
    te.expr = OclUndefined implies te.observation->size() = 1 and te.observation->forAll(o| 
      o.oclIsKindOf(UML!TimeObservation))
); 

helper context UML!Transition def: state_is_external(): Boolean = 
  UML!Transition.allInstances()->forAll(t |
    t.kind = TransitionKind.external implies not(t.source.oclIsKindOf(UML!Pseudostate) and t.source.oclAsType(UML!Pseudostate).kind = PseudostateKind.entryPoint)
); 

helper context UML!Transition def: join_segment_guards(): Boolean = 
  UML!Transition.allInstances()->forAll(t |
    t.target.oclIsKindOf(UML!Pseudostate) and t.target.oclAsType(UML!Pseudostate).kind = PseudostateKind.join implies t.guard = OclUndefined and t.trigger->isEmpty()
); 

helper context UML!Transition def: state_is_internal(): Boolean = 
  UML!Transition.allInstances()->forAll(t |
    t.kind = TransitionKind.internal implies t.source.oclIsKindOf(UML!State) and t.source = t.target
); 

helper context UML!Transition def: outgoing_pseudostates(): Boolean = 
  UML!Transition.allInstances()->forAll(t |
    t.source.oclIsKindOf(UML!Pseudostate) and t.source.oclAsType(UML!Pseudostate).kind <> PseudostateKind.initial implies t.trigger->isEmpty()
); 

helper context UML!Transition def: join_segment_state(): Boolean = 
  UML!Transition.allInstances()->forAll(t |
    t.target.oclIsKindOf(UML!Pseudostate) and t.target.oclAsType(UML!Pseudostate).kind = PseudostateKind.join implies t.source.oclIsKindOf(UML!State)
); 

helper context UML!Transition def: fork_segment_state(): Boolean = 
  UML!Transition.allInstances()->forAll(t |
    t.source.oclIsKindOf(UML!Pseudostate) and t.source.oclAsType(UML!Pseudostate).kind = PseudostateKind.fork implies t.target.oclIsKindOf(UML!State)
); 

helper context UML!Transition def: state_is_local(): Boolean = 
  UML!Transition.allInstances()->forAll(t |
    t.kind = TransitionKind.local implies t.source.oclIsKindOf(UML!State) and t.source.oclAsType(UML!State).isComposite or t.source.oclIsKindOf(UML!Pseudostate) and t.source.oclAsType(UML!Pseudostate).kind = PseudostateKind.entryPoint
); 

helper context UML!Transition def: initial_transition(): Boolean = 
  UML!Transition.allInstances()->forAll(t |
    t.source.oclIsKindOf(UML!Pseudostate) and t.container.stateMachine->oclAsSet()->notEmpty() implies t.trigger->isEmpty()
); 

helper context UML!Transition def: fork_segment_guards(): Boolean = 
  UML!Transition.allInstances()->forAll(t |
    t.source.oclIsKindOf(UML!Pseudostate) and t.source.oclAsType(UML!Pseudostate).kind = PseudostateKind.fork implies t.guard = OclUndefined and t.trigger->isEmpty()
); 

helper context UML!Trigger def: trigger_with_ports(): Boolean = 
  UML!Trigger.allInstances()->forAll(t |
    t.port->notEmpty() implies t.event.oclIsKindOf(UML!MessageEvent)
); 

helper context UML!UnmarshallAction def: structural_feature(): Boolean = 
  UML!UnmarshallAction.allInstances()->forAll(ua |
    ua.unmarshallType.allAttributes()->size() >= 1
); 

helper context UML!UnmarshallAction def: number_of_result(): Boolean = 
  UML!UnmarshallAction.allInstances()->forAll(ua |
    ua.unmarshallType.allAttributes()->size() = ua.result->size()
); 

helper context UML!UnmarshallAction def: type_ordering_and_multiplicity(): Boolean = 
  UML!UnmarshallAction.allInstances()->forAll(ua |
    let attribute : OrderedSet(UML!Property) = 
      ua.unmarshallType.allAttributes() in 
        Sequence{}->forAll(i| 
          attribute->at(i).type.conformsTo(ua.result->at(i).type) and attribute->at(i).isOrdered = ua.result->at(i).isOrdered and attribute->at(i).compatibleWith(ua.result->at(i)))
); 

helper context UML!UnmarshallAction def: multiplicity_of_object(): Boolean = 
  UML!UnmarshallAction.allInstances()->forAll(ua |
    ua.object->is(1,1.toUnlimitedNatural())
); 

helper context UML!UnmarshallAction def: object_type(): Boolean = 
  UML!UnmarshallAction.allInstances()->forAll(ua |
    ua.object.type.conformsTo(ua.unmarshallType)
); 

helper context UML!UseCase def: binary_associations(): Boolean = 
  UML!UseCase.allInstances()->forAll(uc |
    UML!Association->allInstances()->forAll(a| 
      a.memberEnd->collect(p| 
        p.type)->includes(uc) implies a.memberEnd->size() = 2)
); 

helper context UML!UseCase def: no_association_to_use_case(): Boolean = 
  UML!UseCase.allInstances()->forAll(uc |
    UML!Association->allInstances()->forAll(a| 
      a.memberEnd->collect(p| 
        p.type)->includes(uc) implies let usecases : Set(UML!UseCase) = 
        a.memberEnd->collect(p| 
          p.type)->select(t| 
          t.oclIsKindOf(UML!UseCase))->collect(t| 
          t.oclAsType(UML!UseCase))->asSet() in 
          usecases->size() > 1 implies usecases->collect(uc| 
            uc.subject)->size() > 1)
); 

helper context UML!UseCase def: cannot_include_self(): Boolean = 
  UML!UseCase.allInstances()->forAll(uc |
    not(uc.allIncludedUseCases()->includes(uc))
); 

helper context UML!UseCase def: must_have_name(): Boolean = 
  UML!UseCase.allInstances()->forAll(uc |
    uc.name->oclAsSet()->notEmpty()
); 

helper context UML!ValuePin def: no_incoming_edges(): Boolean = 
  UML!ValuePin.allInstances()->forAll(vp |
    vp.incoming->isEmpty()
); 

helper context UML!ValuePin def: compatible_type(): Boolean = 
  UML!ValuePin.allInstances()->forAll(vp |
    vp.value.type.conformsTo(vp.type)
); 

helper context UML!ValueSpecificationAction def: multiplicity(): Boolean = 
  UML!ValueSpecificationAction.allInstances()->forAll(vsa |
    vsa.result->is(1,1.toUnlimitedNatural())
); 

helper context UML!ValueSpecificationAction def: compatible_type(): Boolean = 
  UML!ValueSpecificationAction.allInstances()->forAll(vsa |
    vsa.value.type.conformsTo(vsa.result.type)
); 

helper context UML!VariableAction def: scope_of_variable(): Boolean = 
  UML!VariableAction.allInstances()->forAll(va |
    va.variable.isAccessibleBy(va)
); 

helper context UML!WriteLinkAction def: allow_access(): Boolean = 
  UML!WriteLinkAction.allInstances()->forAll(wla |
    wla.endData->collect(led| 
      led.end)->exists(end| 
      end.type = wla.context or end.visibility = VisibilityKind.public or end.visibility = VisibilityKind.protected and wla.endData->collect(led| 
        led.end)->exists(other| 
        other <> end and wla.context.conformsTo(other.type.oclAsType(UML!Classifier))))
); 

helper context UML!WriteStructuralFeatureAction def: multiplicity_of_result(): Boolean = 
  UML!WriteStructuralFeatureAction.allInstances()->forAll(wsfa |
    wsfa.result <> OclUndefined implies wsfa.result->is(1,1.toUnlimitedNatural())
); 

helper context UML!WriteStructuralFeatureAction def: type_of_value(): Boolean = 
  UML!WriteStructuralFeatureAction.allInstances()->forAll(wsfa |
    wsfa.value <> OclUndefined implies wsfa.value.type.conformsTo(wsfa.structuralFeature.type)
); 

helper context UML!WriteStructuralFeatureAction def: multiplicity_of_value(): Boolean = 
  UML!WriteStructuralFeatureAction.allInstances()->forAll(wsfa |
    wsfa.value <> OclUndefined implies wsfa.value->is(1,1.toUnlimitedNatural())
); 

helper context UML!WriteStructuralFeatureAction def: type_of_result(): Boolean = 
  UML!WriteStructuralFeatureAction.allInstances()->forAll(wsfa |
    wsfa.result <> OclUndefined implies wsfa.result.type = wsfa.object.type
); 

helper context UML!WriteVariableAction def: value_type(): Boolean = 
  UML!WriteVariableAction.allInstances()->forAll(wva |
    wva.value <> OclUndefined implies wva.value.type.conformsTo(wva.variable.type)
); 

helper context UML!WriteVariableAction def: multiplicity(): Boolean = 
  UML!WriteVariableAction.allInstances()->forAll(wva |
    wva.value <> OclUndefined implies wva.value->is(1,1.toUnlimitedNatural())
); 

